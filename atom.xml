<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Mort Yao</title>
    <link href="http://www.soimort.org/atom.xml" rel="self" />
    <link href="http://www.soimort.org" />
    <updated>2013-05-27T21:31:26+08:00</updated>
    <id>http://www.soimort.org</id>
    <author>
        <name>Mort Yao</name>
        <email>mort.yao@soimort.org</email>
    </author>
    
    
    <entry>
        <title>编写可读代码的艺术</title>
        <link href="http://www.soimort.org" />
        <updated>2013-03-21T00:00:00+08:00</updated>
        <id>http://www.soimort.org/readable-code</id>
        <content type="html">&lt;p&gt;这是《The Art of Readable Code》的读书笔记，再加一点自己的认识。强烈推荐此书：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;英文版：&lt;a href=&quot;http://book.douban.com/subject/5442971/&quot; title=&quot;The Art Of Readable Code&quot;&gt;《The Art of Readable Code》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文版：&lt;a href=&quot;http://book.douban.com/subject/10797189/&quot; title=&quot;编写可读代码的艺术&quot;&gt;编写可读代码的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;代码为什么要易于理解&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;&quot;Code should be written to minimize the time it would take for someone else to understand it.&quot;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;日常工作的事实是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;写代码前的思考和看代码的时间远大于真正写的时间&lt;/li&gt;
&lt;li&gt;读代码是很平常的事情，不论是别人的，还是自己的，半年前写的可认为是别人的代码&lt;/li&gt;
&lt;li&gt;代码可读性高，很快就可以理解程序的逻辑，进入工作状态&lt;/li&gt;
&lt;li&gt;行数少的代码不一定就容易理解&lt;/li&gt;
&lt;li&gt;代码的可读性与程序的效率、架构、易于测试一点也不冲突&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;整本书都围绕“如何让代码的可读性更高”这个目标来写。这也是好代码的重要标准之一。&lt;/p&gt;

&lt;h2&gt;如何命名&lt;/h2&gt;

&lt;h3&gt;变量名中应包含更多信息&lt;/h3&gt;

&lt;h4&gt;使用含义明确的词，比如用&lt;code&gt;download&lt;/code&gt;而不是&lt;code&gt;get&lt;/code&gt;，参考以下替换方案：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt; send -&amp;gt; deliver, dispatch, announce, distribute, route
 find -&amp;gt; search, extract, locate, recover
start -&amp;gt; lanuch, create, begin, open
 make -&amp;gt; create,set up, build, generate, compose, add, new
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;避免通用的词&lt;/h4&gt;

&lt;p&gt;像&lt;code&gt;tmp&lt;/code&gt;和&lt;code&gt;retval&lt;/code&gt;这样词，除了说明是临时变量和返回值之外，没有任何意义。但是给他加一些有意义的词，就会很明确：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tmp_file = tempfile.NamedTemporaryFile() 
...
SaveData(tmp_file, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不使用retval而使用变量真正代表的意义：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sum_squares += v[i]; // Where's the &quot;square&quot; that we're summing? Bug!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;嵌套的for循环中,&lt;code&gt;i&lt;/code&gt;、&lt;code&gt;j&lt;/code&gt;也有同样让人困惑的时候：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; clubs.size(); i++)
    for (int j = 0; j &amp;lt; clubs[i].members.size(); j++)
        for (int k = 0; k &amp;lt; users.size(); k++) if (clubs[i].members[k] == users[j])
            cout &amp;lt;&amp;lt; &quot;user[&quot; &amp;lt;&amp;lt; j &amp;lt;&amp;lt; &quot;] is in club[&quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot;]&quot; &amp;lt;&amp;lt; endl;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换一种写法就会清晰很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; if (clubs[ci].members[mi] == users[ui])  # OK. First letters match.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以，当使用一些通用的词，要有充分的理由才可以。&lt;/p&gt;

&lt;h4&gt;使用具体的名字&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;CanListenOnPort&lt;/code&gt;就比&lt;code&gt;ServerCanStart&lt;/code&gt;好，can start比较含糊，而listen on port确切的说明了这个方法将要做什么。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;--run_locally&lt;/code&gt;就不如&lt;code&gt;--extra_logging&lt;/code&gt;来的明确。&lt;/p&gt;

&lt;h4&gt;增加重要的细节，比如变量的单位&lt;code&gt;_ms&lt;/code&gt;，对原始字符串加&lt;code&gt;_raw&lt;/code&gt;&lt;/h4&gt;

&lt;p&gt;如果一个变量很重要，那么在名字上多加一些额外的字就会更加易读，比如将&lt;code&gt;string id; // Example: &quot;af84ef845cd8&quot;&lt;/code&gt;换成&lt;code&gt;string hex_id;&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;             Start(int delay)  --&amp;gt;  delay → delay_secs
        CreateCache(int size)  --&amp;gt;  size → size_mb
ThrottleDownload(float limit)  --&amp;gt;  limit → max_kbps
          Rotate(float angle)  --&amp;gt;  angle → degrees_cw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更多例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;password  -&amp;gt;  plaintext_password
 comment  -&amp;gt;  unescaped_comment
    html  -&amp;gt;  html_utf8
    data  -&amp;gt;  data_urlenc
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;对于作用域大的变量使用较长的名字&lt;/h4&gt;

&lt;p&gt;在比较小的作用域内，可以使用较短的变量名，在较大的作用域内使用的变量，最好用长一点的名字，编辑器的自动补全都可以很好的减少键盘输入。对于一些缩写前缀，尽量选择众所周知的(如str)，一个判断标准是，当新成员加入时，是否可以无需他人帮助而明白前缀代表什么。&lt;/p&gt;

&lt;h4&gt;合理使用&lt;code&gt;_&lt;/code&gt;、&lt;code&gt;-&lt;/code&gt;等符号，比如对私有变量加&lt;code&gt;_&lt;/code&gt;前缀。&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var x = new DatePicker(); // DatePicker() 是类的&quot;构造&quot;函数，大写开始
var y = pageHeight(); // pageHeight() 是一个普通函数

var $all_images = $(&quot;img&quot;); // $all_images 是jQuery对象
var height = 250; // height不是

//id和class的写法分开
&amp;lt;div id=&quot;middle_column&quot; class=&quot;main-content&quot;&amp;gt; ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;命名不能有歧义&lt;/h3&gt;

&lt;p&gt;命名的时候可以先想一下，我要用的这个词是否有别的含义。举个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;results = Database.all_objects.filter(&quot;year &amp;lt;= 2011&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;现在的结果到底是包含2011年之前的呢还是不包含呢？&lt;/p&gt;

&lt;h4&gt;使用&lt;code&gt;min&lt;/code&gt;、&lt;code&gt;max&lt;/code&gt;代替&lt;code&gt;limit&lt;/code&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;CART_TOO_BIG_LIMIT = 10
    if shopping_cart.num_items() &amp;gt;= CART_TOO_BIG_LIMIT:
        Error(&quot;Too many items in cart.&quot;)

MAX_ITEMS_IN_CART = 10
    if shopping_cart.num_items() &amp;gt; MAX_ITEMS_IN_CART:
     Error(&quot;Too many items in cart.&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对比上例中&lt;code&gt;CART_TOO_BIG_LIMIT&lt;/code&gt;和&lt;code&gt;MAX_ITEMS_IN_CART&lt;/code&gt;，想想哪个更好呢？&lt;/p&gt;

&lt;h4&gt;使用&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;last&lt;/code&gt;来表示闭区间&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;print integer_range(start=2, stop=4)
# Does this print [2,3] or [2,3,4] (or something else)?

set.PrintKeys(first=&quot;Bart&quot;, last=&quot;Maggie&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;first&lt;/code&gt;和&lt;code&gt;last&lt;/code&gt;含义明确，适宜表示闭区间。&lt;/p&gt;

&lt;h4&gt;使用&lt;code&gt;beigin&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;表示前闭后开([2,9))区间&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;PrintEventsInRange(&quot;OCT 16 12:00am&quot;, &quot;OCT 17 12:00am&quot;)

PrintEventsInRange(&quot;OCT 16 12:00am&quot;, &quot;OCT 16 11:59:59.9999pm&quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面一种写法就比下面的舒服多了。&lt;/p&gt;

&lt;h4&gt;Boolean型变量命名&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;bool read_password = true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个很危险的命名，到底是需要读取密码呢，还是密码已经被读取呢，不知道，所以这个变量可以使用&lt;code&gt;user_is_authenticated&lt;/code&gt;代替。通常，给Boolean型变量添加&lt;code&gt;is&lt;/code&gt;、&lt;code&gt;has&lt;/code&gt;、&lt;code&gt;can&lt;/code&gt;、&lt;code&gt;should&lt;/code&gt;可以让含义更清晰，比如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;             SpaceLeft()  --&amp;gt;  hasSpaceLeft()
bool disable_ssl = false  --&amp;gt;  bool use_ssl = true
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;符合预期&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public class StatisticsCollector {
    public void addSample(double x) { ... }
    public double getMean() {
        // Iterate through all samples and return total / num_samples
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，&lt;code&gt;getMean&lt;/code&gt;方法遍历了所有的样本，返回总额，所以并不是普通意义上轻量的&lt;code&gt;get&lt;/code&gt;方法，所以应该取名&lt;code&gt;computeMean&lt;/code&gt;比较合适。&lt;/p&gt;

&lt;h2&gt;漂亮的格式&lt;/h2&gt;

&lt;p&gt;写出来漂亮的格式，充满美感，读起来自然也会舒服很多，对比下面两个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class StatsKeeper {
   public:
   // A class for keeping track of a series of doubles
      void Add(double d);  // and methods for quick statistics about them
     private:   int count;        /* how many so    far
   */ public:
           double Average();
   private:   double minimum;
   list&amp;lt;double&amp;gt;
     past_items
         ;double maximum;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;什么是充满美感的呢：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// A class for keeping track of a series of doubles
// and methods for quick statistics about them.
class StatsKeeper {
  public:
    void Add(double d);
    double Average();
  private:
    list&amp;lt;double&amp;gt; past_items;
    int count;  // how many so far
    double minimum;
    double maximum;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;考虑断行的连续性和简洁&lt;/h3&gt;

&lt;p&gt;这段代码需要断行，来满足不超过一行80个字符的要求，参数也需要注释说明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PerformanceTester {
    public static final TcpConnectionSimulator wifi = new TcpConnectionSimulator(
        500, /* Kbps */
        80, /* millisecs latency */
        200, /* jitter */
        1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber = new TcpConnectionSimulator(
        45000, /* Kbps */
        10, /* millisecs latency */
        0, /* jitter */
        0 /* packet loss % */);

    public static final TcpConnectionSimulator cell = new TcpConnectionSimulator(
        100, /* Kbps */
        400, /* millisecs latency */
        250, /* jitter */
        5 /* packet loss % */);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;考虑到代码的连贯性，先优化成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PerformanceTester {
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(
            500, /* Kbps */
            80, /* millisecs latency */ 200, /* jitter */
            1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(
            45000, /* Kbps */
            10,    /* millisecs latency */
            0,     /* jitter */
            0      /* packet loss % */);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(
            100,   /* Kbps */
            400,   /* millisecs latency */
            250,   /* jitter */
            5      /* packet loss % */);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;连贯性好一点，但还是太罗嗦，额外占用很多空间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public class PerformanceTester {
    // TcpConnectionSimulator(throughput, latency, jitter, packet_loss)
    //                            [Kbps]   [ms]    [ms]    [percent]
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(500,    80,     200,     1);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(45000,  10,     0,       0);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(100,    400,    250,     5);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;用函数封装&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// Turn a partial_name like &quot;Doug Adams&quot; into &quot;Mr. Douglas Adams&quot;.
// If not possible, 'error' is filled with an explanation.
string ExpandFullName(DatabaseConnection dc, string partial_name, string* error);

DatabaseConnection database_connection;
string error;
assert(ExpandFullName(database_connection, &quot;Doug Adams&quot;, &amp;amp;error)
        == &quot;Mr. Douglas Adams&quot;);
assert(error == &quot;&quot;);
assert(ExpandFullName(database_connection, &quot; Jake Brown &quot;, &amp;amp;error)
        == &quot;Mr. Jacob Brown III&quot;);
assert(error == &quot;&quot;);
assert(ExpandFullName(database_connection, &quot;No Such Guy&quot;, &amp;amp;error) == &quot;&quot;);
assert(error == &quot;no match found&quot;);
assert(ExpandFullName(database_connection, &quot;John&quot;, &amp;amp;error) == &quot;&quot;);
assert(error == &quot;more than one result&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这段代码看起来很脏乱，很多重复性的东西，可以用函数封装：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CheckFullName(&quot;Doug Adams&quot;, &quot;Mr. Douglas Adams&quot;, &quot;&quot;);
CheckFullName(&quot; Jake Brown &quot;, &quot;Mr. Jake Brown III&quot;, &quot;&quot;);
CheckFullName(&quot;No Such Guy&quot;, &quot;&quot;, &quot;no match found&quot;);
CheckFullName(&quot;John&quot;, &quot;&quot;, &quot;more than one result&quot;);

void CheckFullName(string partial_name,
                   string expected_full_name,
                   string expected_error) {
    // database_connection is now a class member
    string error;
    string full_name = ExpandFullName(database_connection, partial_name, &amp;amp;error);
    assert(error == expected_error);
    assert(full_name == expected_full_name);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;列对齐&lt;/h3&gt;

&lt;p&gt;列对齐可以让代码段看起来更舒适：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CheckFullName(&quot;Doug Adams&quot;   , &quot;Mr. Douglas Adams&quot; , &quot;&quot;);
CheckFullName(&quot; Jake  Brown &quot;, &quot;Mr. Jake Brown III&quot;, &quot;&quot;);
CheckFullName(&quot;No Such Guy&quot;  , &quot;&quot;                  , &quot;no match found&quot;);
CheckFullName(&quot;John&quot;         , &quot;&quot;                  , &quot;more than one result&quot;);

commands[] = {
    ...
    { &quot;timeout&quot;      , NULL              , cmd_spec_timeout},
    { &quot;timestamping&quot; , &amp;amp;opt.timestamping , cmd_boolean},
    { &quot;tries&quot;        , &amp;amp;opt.ntry         , cmd_number_inf},
    { &quot;useproxy&quot;     , &amp;amp;opt.use_proxy    , cmd_boolean},
    { &quot;useragent&quot;    , NULL              , cmd_spec_useragent},
    ...
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;代码用块区分&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;class FrontendServer {
    public:
        FrontendServer();
        void ViewProfile(HttpRequest* request);
        void OpenDatabase(string location, string user);
        void SaveProfile(HttpRequest* request);
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void FindFriends(HttpRequest* request);
        void ReplyNotFound(HttpRequest* request, string error);
        void CloseDatabase(string location);
        ~FrontendServer();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这一段虽然能看，不过还有优化空间：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class FrontendServer {
    public:
        FrontendServer();
        ~FrontendServer();
        // Handlers
        void ViewProfile(HttpRequest* request);
        void SaveProfile(HttpRequest* request);
        void FindFriends(HttpRequest* request);

        // Request/Reply Utilities
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void ReplyNotFound(HttpRequest* request, string error);

        // Database Helpers
        void OpenDatabase(string location, string user);
        void CloseDatabase(string location);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来看一段代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Import the user's email contacts, and match them to users in our system.
# Then display a list of those users that he/she isn't already friends with.
def suggest_new_friends(user, email_password):
    friends = user.friends()
    friend_emails = set(f.email for f in friends)
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)
    display['user'] = user
    display['friends'] = friends
    display['suggested_friends'] = suggested_friends
    return render(&quot;suggested_friends.html&quot;, display)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全都混在一起，视觉压力相当大，按功能化块：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def suggest_new_friends(user, email_password):
    # Get the user's friends' email addresses.
    friends = user.friends()
    friend_emails = set(f.email for f in friends)

    # Import all email addresses from this user's email account.
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)

    # Find matching users that they aren't already friends with.
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)

    # Display these lists on the page. display['user'] = user
    display['friends'] = friends
    display['suggested_friends'] = suggested_friends

    return render(&quot;suggested_friends.html&quot;, display)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;让代码看起来更舒服，需要在写的过程中多注意，培养一些好的习惯，尤其当团队合作的时候，代码风格比如大括号的位置并没有对错，但是不遵循团队规范那就是错的。&lt;/p&gt;

&lt;h2&gt;如何写注释&lt;/h2&gt;

&lt;p&gt;当你写代码的时候，你会思考很多，但是最终呈现给读者的就只剩代码本身了，额外的信息丢失了，所以注释的目的就是让读者了解更多的信息。&lt;/p&gt;

&lt;h3&gt;应该注释什么&lt;/h3&gt;

&lt;h4&gt;不应该注释什么&lt;/h4&gt;

&lt;p&gt;这样的注释毫无价值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// The class definition for Account
class Account {
    public:
        // Constructor
        Account();
        // Set the profit member to a new value
        void SetProfit(double profit);
        // Return the profit from this Account
        double GetProfit();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;不要像下面这样为了注释而注释：&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Find a Node with the given 'name' or return NULL.
// If depth &amp;lt;= 0, only 'subtree' is inspected.
// If depth == N, only 'subtree' and N levels below are inspected.
Node* FindNodeInSubtree(Node* subtree, string name, int depth);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;不要给烂取名注释&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Enforce limits on the Reply as stated in the Request,
// such as the number of items returned, or total byte size, etc. 
void CleanReply(Request request, Reply reply);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注释的大部分都在解释clean是什么意思，那不如换个正确的名字：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Make sure 'reply' meets the count/byte/etc. limits from the 'request' 
void EnforceLimitsFromRequest(Request request, Reply reply);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;记录你的想法&lt;/h4&gt;

&lt;p&gt;我们讨论了不该注释什么，那么应该注释什么呢？注释应该记录你思考代码怎么写的结果，比如像下面这些：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Surprisingly, a binary tree was 40% faster than a hash table for this data.
// The cost of computing a hash was more than the left/right comparisons.

// This heuristic might miss a few words. That's OK; solving this 100% is hard.

// This class is getting messy. Maybe we should create a 'ResourceNode' subclass to
// help organize things.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以用来记录流程和常量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// TODO: use a faster algorithm
// TODO(dustin): handle other image formats besides JPEG

NUM_THREADS = 8 # as long as it's &amp;gt;= 2 * num_processors, that's good enough.

// Impose a reasonable limit - no human can read that much anyway.
const int MAX_RSS_SUBSCRIPTIONS = 1000;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可用的词有：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;TODO  : Stuff I haven't gotten around to yet
FIXME : Known-broken code here
HACK  : Adimittedly inelegant solution to a problem
XXX   : Danger! Major problem here
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;站在读者的角度去思考&lt;/h4&gt;

&lt;p&gt;当别人读你的代码时，让他们产生疑问的部分，就是你应该注释的地方。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Recorder {
    vector&amp;lt;float&amp;gt; data;
    ...
    void Clear() {
        vector&amp;lt;float&amp;gt;().swap(data); // Huh? Why not just data.clear()? 
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多C++的程序员啊看到这里，可能会想为什么不用&lt;code&gt;data.clear()&lt;/code&gt;来代替&lt;code&gt;vector.swap&lt;/code&gt;，所以那个地方应该加上注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Force vector to relinquish its memory (look up &quot;STL swap trick&quot;)
vector&amp;lt;float&amp;gt;().swap(data);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;说明可能陷阱&lt;/h4&gt;

&lt;p&gt;你在写代码的过程中，可能用到一些hack，或者有其他需要读代码的人知道的陷阱，这时候就应该注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void SendEmail(string to, string subject, string body);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;而实际上这个发送邮件的函数是调用别的服务，有超时设置，所以需要注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Calls an external service to deliver email.  (Times out after 1 minute.)
void SendEmail(string to, string subject, string body);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;全景的注释&lt;/h4&gt;

&lt;p&gt;有时候为了更清楚说明，需要给整个文件加注释，让读者有个总体的概念：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// This file contains helper functions that provide a more convenient interface to our
// file system. It handles file permissions and other nitty-gritty details.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;总结性的注释&lt;/h4&gt;

&lt;p&gt;即使是在函数内部，也可以有类似文件注释那样的说明注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Find all the items that customers purchased for themselves.
for customer_id in all_customers:
    for sale in all_sales[customer_id].sales:
        if sale.recipient == customer_id:
            ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者按照函数的步进，写一些注释：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def GenerateUserReport():
    # Acquire a lock for this user
    ...
    # Read user's info from the database
    ...
    # Write info to a file
    ...
    # Release the lock for this user
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;很多人不愿意写注释，确实，要写好注释也不是一件简单的事情，也可以在文件专门的地方，留个写注释的区域，可以写下你任何想说的东西。&lt;/p&gt;

&lt;h3&gt;注释应简明准确&lt;/h3&gt;

&lt;p&gt;前一个小节讨论了注释应该写什么，这一节来讨论应该怎么写，因为注释很重要，所以要写的精确，注释也占据屏幕空间，所以要简洁。&lt;/p&gt;

&lt;h4&gt;精简注释&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// The int is the CategoryType.
// The first float in the inner pair is the 'score',
// the second is the 'weight'.
typedef hash_map&amp;lt;int, pair&amp;lt;float, float&amp;gt; &amp;gt; ScoreMap;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样写太罗嗦了，尽量精简压缩成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// CategoryType -&amp;gt; (score, weight)
typedef hash_map&amp;lt;int, pair&amp;lt;float, float&amp;gt; &amp;gt; ScoreMap;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;避免有歧义的代词&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Insert the data into the cache, but check if it's too big first.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;it's&lt;/code&gt;有歧义，不知道所指的是&lt;code&gt;data&lt;/code&gt;还是&lt;code&gt;cache&lt;/code&gt;，改成如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Insert the data into the cache, but check if the data is too big first.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有更好的解决办法，这里的&lt;code&gt;it&lt;/code&gt;就有明确所指：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// If the data is small enough, insert it into the cache.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;语句要精简准确&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# Depending on whether we've already crawled this URL before, give it a different priority.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这句话理解起来太费劲，改成如下就好理解很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Give higher priority to URLs we've never crawled before.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;精确描述函数的目的&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Return the number of lines in this file.
int CountLines(string filename) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的一个函数，用起来可能会一头雾水，因为他可以有很多歧义：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&quot;&quot; 一个空文件，是0行还是1行？&lt;/li&gt;
&lt;li&gt;&quot;hello&quot; 只有一行，那么返回值是0还是1？&lt;/li&gt;
&lt;li&gt;&quot;hello\n&quot; 这种情况返回1还是2？&lt;/li&gt;
&lt;li&gt;&quot;hello\n world&quot; 返回1还是2？&lt;/li&gt;
&lt;li&gt;&quot;hello\n\r cruel\n world\r&quot; 返回2、3、4哪一个呢？&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以注释应该这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Count how many newline bytes ('\n') are in the file.
int CountLines(string filename) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;用实例说明边界情况&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// Rearrange 'v' so that elements &amp;lt; pivot come before those &amp;gt;= pivot;
// Then return the largest 'i' for which v[i] &amp;lt; pivot (or -1 if none are &amp;lt; pivot)
int Partition(vector&amp;lt;int&amp;gt;* v, int pivot);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个描述很精确，但是如果再加入一个例子，就更好了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// ...
// Example: Partition([8 5 9 8 2], 8) might result in [5 2 | 8 9 8] and return 1
int Partition(vector&amp;lt;int&amp;gt;* v, int pivot);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;说明你的代码的真正目的&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;void DisplayProducts(list&amp;lt;Product&amp;gt; products) {
    products.sort(CompareProductByPrice);
    // Iterate through the list in reverse order
    for (list&amp;lt;Product&amp;gt;::reverse_iterator it = products.rbegin(); it != products.rend();
            ++it)
        DisplayPrice(it-&amp;gt;price);
    ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的注释说明了倒序排列，单还不够准确，应该改成这样：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Display each price, from highest to lowest
for (list&amp;lt;Product&amp;gt;::reverse_iterator it = products.rbegin(); ... )
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;函数调用时的注释&lt;/h4&gt;

&lt;p&gt;看见这样的一个函数调用，肯定会一头雾水：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Connect(10, false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果加上这样的注释，读起来就清楚多了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def Connect(timeout, use_encryption):  ...

# Call the function using named parameters
Connect(timeout = 10, use_encryption = False)
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;使用信息含量丰富的词&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;// This class contains a number of members that store the same information as in the
// database, but are stored here for speed. When this class is read from later, those
// members are checked first to see if they exist, and if so are returned; otherwise the
// database is read from and that data stored in those fields for next time.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这一大段注释，解释的很清楚，如果换一个词来代替，也不会有什么疑惑：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// This class acts as a caching layer to the database.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;简化循环和逻辑&lt;/h2&gt;

&lt;h3&gt;流程控制要简单&lt;/h3&gt;

&lt;p&gt;让条件语句、循环以及其他控制流程的代码尽可能自然，让读者在阅读过程中不需要停顿思考或者在回头查找，是这一节的目的。&lt;/p&gt;

&lt;h4&gt;条件语句中参数的位置&lt;/h4&gt;

&lt;p&gt;对比下面两种条件的写法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (length &amp;gt;= 10)
while (bytes_received &amp;lt; bytes_expected)

if (10 &amp;lt;= length)
while (bytes_expected &amp;gt; bytes_received)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到底是应该按照大于小于的顺序来呢，还是有其他的准则？是的，应该按照参数的意义来&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;运算符左边：通常是需要被检查的变量，也就是会经常变化的&lt;/li&gt;
&lt;li&gt;运算符右边：通常是被比对的样本，一定程度上的常量&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;这就解释了为什么&lt;code&gt;bytes_received &amp;lt; bytes_expected&lt;/code&gt;比反过来更好理解。&lt;/p&gt;

&lt;h4&gt;if/else的顺序&lt;/h4&gt;

&lt;p&gt;通常，&lt;code&gt;if/else&lt;/code&gt;的顺序你可以自由选择，下面这两种都可以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (a == b) {
    // Case One ...
} else {
    // Case Two ...
}

if (a != b) {
    // Case Two ...
} else {
    // Case One ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或许对此你也没有仔细斟酌过，但在有些时候，一种顺序确实好过另一种：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;正向的逻辑在前，比如&lt;code&gt;if(debug)&lt;/code&gt;就比&lt;code&gt;if(!debug)&lt;/code&gt;好&lt;/li&gt;
&lt;li&gt;简单逻辑的在前，这样&lt;code&gt;if&lt;/code&gt;和&lt;code&gt;else&lt;/code&gt;就可以在一个屏幕显示&lt;/li&gt;
&lt;li&gt;有趣、清晰的逻辑在前&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;举个例子来看：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!url.HasQueryParameter(&quot;expand_all&quot;)) {
    response.Render(items);
    ...
} else {
    for (int i = 0; i &amp;lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看到&lt;code&gt;if&lt;/code&gt;你首先想到的是&lt;code&gt;expand_all&lt;/code&gt;，就好像告诉你“不要想大象”，你会忍不住去想它，所以产生了一点点迷惑，最好写成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (url.HasQueryParameter(&quot;expand_all&quot;)) {
    for (int i = 0; i &amp;lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
} else {
    response.Render(items);
    ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;三目运算符(?:)&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;time_str += (hour &amp;gt;= 12) ? &quot;pm&quot; : &quot;am&quot;;

Avoiding the ternary operator, you might write:
    if (hour &amp;gt;= 12) {
        time_str += &quot;pm&quot;;
    } else {
        time_str += &quot;am&quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用三目运算符可以减少代码行数，上例就是一个很好的例证，但是我们的真正目的是减少读代码的时间，所以下面的情况并不适合用三目运算符：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return exponent &amp;gt;= 0 ? mantissa * (1 &amp;lt;&amp;lt; exponent) : mantissa / (1 &amp;lt;&amp;lt; -exponent);

if (exponent &amp;gt;= 0) {
    return mantissa * (1 &amp;lt;&amp;lt; exponent);
} else {
    return mantissa / (1 &amp;lt;&amp;lt; -exponent);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以只在简单表达式的地方用。&lt;/p&gt;

&lt;h4&gt;避免使用do/while表达式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;do {
    continue;
} while (false);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码会执行几遍呢，需要时间思考一下，&lt;code&gt;do/while&lt;/code&gt;完全可以用别的方法代替，所以应避免使用。&lt;/p&gt;

&lt;h4&gt;尽早return&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;public boolean Contains(String str, String substr) {
    if (str == null || substr == null) return false;
    if (substr.equals(&quot;&quot;)) return true;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数里面尽早的return，可以让逻辑更加清晰。&lt;/p&gt;

&lt;h4&gt;减少嵌套&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;if (user_result == SUCCESS) {
    if (permission_result != SUCCESS) {
        reply.WriteErrors(&quot;error reading permissions&quot;);
        reply.Done();
        return;
    }
    reply.WriteErrors(&quot;&quot;);
} else {
    reply.WriteErrors(user_result);
}
reply.Done();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样一段代码，有一层的嵌套，但是看起来也会稍有迷惑，想想自己的代码，有没有类似的情况呢？可以换个思路去考虑这段代码，并且用尽早return的原则修改，看起来就舒服很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (user_result != SUCCESS) {
    reply.WriteErrors(user_result);
    reply.Done();
    return;
}
if (permission_result != SUCCESS) {
    reply.WriteErrors(permission_result);
    reply.Done();
    return;
}
reply.WriteErrors(&quot;&quot;);
reply.Done();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;同样的，对于有嵌套的循环，可以采用同样的办法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; results.size(); i++) {
    if (results[i] != NULL) {
        non_null_count++;
        if (results[i]-&amp;gt;name != &quot;&quot;) {
            cout &amp;lt;&amp;lt; &quot;Considering candidate...&quot; &amp;lt;&amp;lt; endl;
            ...
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换一种写法，尽早return，在循环中就用continue：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (int i = 0; i &amp;lt; results.size(); i++) {
    if (results[i] == NULL) continue;
    non_null_count++;

    if (results[i]-&amp;gt;name == &quot;&quot;) continue;
    cout &amp;lt;&amp;lt; &quot;Considering candidate...&quot; &amp;lt;&amp;lt; endl;
    ... 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;拆分复杂表达式&lt;/h3&gt;

&lt;p&gt;很显然的，越复杂的表达式，读起来越费劲，所以应该把那些复杂而庞大的表达式，拆分成一个个易于理解的小式子。&lt;/p&gt;

&lt;h4&gt;用变量&lt;/h4&gt;

&lt;p&gt;将复杂表达式拆分最简单的办法，就是增加一个变量：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if line.split(':')[0].strip() == &quot;root&quot;:

//用变量替换
username = line.split(':')[0].strip() 
if username == &quot;root&quot;:
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者这个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (request.user.id == document.owner_id) {
    // user can edit this document...
}
...
if (request.user.id != document.owner_id) {
// document is read-only...
}

//用变量替换
final boolean user_owns_document = (request.user.id == document.owner_id);
if (user_owns_document) {
    // user can edit this document...
}
...
if (!user_owns_document) {
    // document is read-only...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;逻辑替换&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;1) not (a or b or c)   &amp;lt;--&gt; (not a) and (not b) and (not c)&lt;/li&gt;
&lt;li&gt;2) not (a and b and c) &amp;lt;--&gt; (not a) or (not b) or (not c)&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以，就可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!(file_exists &amp;amp;&amp;amp; !is_protected)) Error(&quot;Sorry, could not read file.&quot;);

//替换
if (!file_exists || is_protected) Error(&quot;Sorry, could not read file.&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;不要滥用逻辑表达式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;assert((!(bucket = FindBucket(key))) || !bucket-&amp;gt;IsOccupied());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样的代码完全可以用下面这个替换，虽然有两行，但是更易懂：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bucket = FindBucket(key);
if (bucket != NULL) assert(!bucket-&amp;gt;IsOccupied());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;像下面这样的表达式，最好也不要写，因为在有些语言中，x会被赋予第一个为&lt;code&gt;true&lt;/code&gt;的变量的值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;x = a || b || c
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;拆解大表达式&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;var update_highlight = function (message_num) {
    if ($(&quot;#vote_value&quot; + message_num).html() === &quot;Up&quot;) {
        $(&quot;#thumbs_up&quot; + message_num).addClass(&quot;highlighted&quot;);
        $(&quot;#thumbs_down&quot; + message_num).removeClass(&quot;highlighted&quot;);
    } else if ($(&quot;#vote_value&quot; + message_num).html() === &quot;Down&quot;) {
        $(&quot;#thumbs_up&quot; + message_num).removeClass(&quot;highlighted&quot;);
        $(&quot;#thumbs_down&quot; + message_num).addClass(&quot;highlighted&quot;);
    } else {
        $(&quot;#thumbs_up&quot; + message_num).removeClass(&quot;highighted&quot;);
        $(&quot;#thumbs_down&quot; + message_num).removeClass(&quot;highlighted&quot;);
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里面有很多重复的语句，我们可以用变量还替换简化：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var update_highlight = function (message_num) {
    var thumbs_up = $(&quot;#thumbs_up&quot; + message_num);
    var thumbs_down = $(&quot;#thumbs_down&quot; + message_num);
    var vote_value = $(&quot;#vote_value&quot; + message_num).html();
    var hi = &quot;highlighted&quot;;

    if (vote_value === &quot;Up&quot;) {
        thumbs_up.addClass(hi);
        thumbs_down.removeClass(hi);
    } else if (vote_value === &quot;Down&quot;) {
        thumbs_up.removeClass(hi);
        thumbs_down.addClass(hi);
    } else {
        thumbs_up.removeClass(hi);
        thumbs_down.removeClass(hi);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;变量与可读性&lt;/h3&gt;

&lt;h4&gt;消除变量&lt;/h4&gt;

&lt;p&gt;前一节，讲到利用变量来拆解大表达式，这一节来讨论如何消除多余的变量。&lt;/p&gt;

&lt;h4&gt;没用的临时变量&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;now = datetime.datetime.now()
root_message.last_view_time = now
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;now&lt;/code&gt;可以去掉，因为：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;并非用来拆分复杂的表达式&lt;/li&gt;
&lt;li&gt;也没有增加可读性，因为`datetime.datetime.now()`本就清晰&lt;/li&gt;
&lt;li&gt;只用了一次&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;所以完全可以写作：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;root_message.last_view_time = datetime.datetime.now()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;消除条件控制变量&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;boolean done = false;
while (/* condition */ &amp;amp;&amp;amp; !done) {
    ...
    if (...) {
        done = true;
        continue; 
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;done&lt;/code&gt;可以用别的方式更好的完成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;while (/* condition */) {
    ...
    if (...) {
        break;
    } 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子非常容易修改，如果是比较复杂的嵌套，&lt;code&gt;break&lt;/code&gt;可能并不够用，这时候就可以把代码封装到函数中。&lt;/p&gt;

&lt;h4&gt;减少变量的作用域&lt;/h4&gt;

&lt;p&gt;我们都听过要避免使用全局变量这样的忠告，是的，当变量的作用域越大，就越难追踪，所以要保持变量小的作用域。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class LargeClass {
    string str_;
    void Method1() {
        str_ = ...;
        Method2();
    }
    void Method2() {
        // Uses str_
    }
    // Lots of other methods that don't use str_ 
    ... ;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这里的&lt;code&gt;str_&lt;/code&gt;的作用域有些大，完全可以换一种方式：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class LargeClass {
    void Method1() {
        string str = ...;
        Method2(str); 
    }
    void Method2(string str) {
        // Uses str
    }
    // Now other methods can't see str.
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;将&lt;code&gt;str&lt;/code&gt;通过变量函数参数传递，减小了作用域，也更易读。同样的道理也可以用在定义类的时候，将大类拆分成一个个小类。&lt;/p&gt;

&lt;h4&gt;不要使用嵌套的作用域&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;# No use of example_value up to this point.
if request:
    for value in request.values:
    if value &amp;gt; 0:
        example_value = value 
        break

for logger in debug.loggers:
    logger.log(&quot;Example:&quot;, example_value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个例子在运行时候会报&lt;code&gt;example_value is undefined&lt;/code&gt;的错，修改起来不算难：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;example_value = None
if request:
    for value in request.values:
        if value &amp;gt; 0: example_value = value 
        break

if example_value:
    for logger in debug.loggers:
    logger.log(&quot;Example:&quot;, example_value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是参考前面的&lt;strong&gt;消除中间变量&lt;/strong&gt;准则，还有更好的办法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def LogExample(value):
    for logger in debug.loggers:
        logger.log(&quot;Example:&quot;, value)

    if request:
        for value in request.values:
            if value &amp;gt; 0:
                LogExample(value)  # deal with 'value' immediately
                break
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;用到了再声明&lt;/h4&gt;

&lt;p&gt;在C语言中，要求将所有的变量事先声明，这样当用到变量较多时候，读者处理这些信息就会有难度，所以一开始没用到的变量，就暂缓声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def ViewFilteredReplies(original_id):
    filtered_replies = []
    root_message = Messages.objects.get(original_id) 
    all_replies = Messages.objects.select(root_id=original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    for reply in all_replies:
        if reply.spam_votes &amp;lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;读者一次处理变量太多，可以暂缓声明：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def ViewFilteredReplies(original_id):
    root_message = Messages.objects.get(original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    all_replies = Messages.objects.select(root_id=original_id) 
    filtered_replies = []
    for reply in all_replies:
        if reply.spam_votes &amp;lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;变量最好只写一次&lt;/h4&gt;

&lt;p&gt;前面讨论了过多的变量会让读者迷惑，同一个变量，不停的被赋值也会让读者头晕，如果变量变化的次数少一些，代码可读性就更强。&lt;/p&gt;

&lt;h4&gt;一个例子&lt;/h4&gt;

&lt;p&gt;假设有一个页面，如下，需要给第一个空的&lt;code&gt;input&lt;/code&gt;赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;input type=&quot;text&quot; id=&quot;input1&quot; value=&quot;Dustin&quot;&amp;gt;
&amp;lt;input type=&quot;text&quot; id=&quot;input2&quot; value=&quot;Trevor&quot;&amp;gt;
&amp;lt;input type=&quot;text&quot; id=&quot;input3&quot; value=&quot;&quot;&amp;gt;
&amp;lt;input type=&quot;text&quot; id=&quot;input4&quot; value=&quot;Melissa&quot;&amp;gt;
...
var setFirstEmptyInput = function (new_value) {
    var found = false;
    var i = 1;
    var elem = document.getElementById('input' + i);
    while (elem !== null) {
        if (elem.value === '') {
            found = true;
            break; 
        }
        i++;
        elem = document.getElementById('input' + i);
    }
    if (found) elem.value = new_value;
    return elem;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码能工作，有三个变量，我们逐一去看如何优化，&lt;code&gt;found&lt;/code&gt;作为中间变量，完全可以消除：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var setFirstEmptyInput = function (new_value) {
    var i = 1;
    var elem = document.getElementById('input' + i);
    while (elem !== null) {
        if (elem.value === '') {
            elem.value = new_value;
            return elem;
        }
        i++;
        elem = document.getElementById('input' + i);
    }
    return null;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来看&lt;code&gt;elem&lt;/code&gt;变量，只用来做循环，调用了很多次，所以很难跟踪他的值，&lt;code&gt;i&lt;/code&gt;也可以用&lt;code&gt;for&lt;/code&gt;来修改：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var setFirstEmptyInput = function (new_value) {
    for (var i = 1; true; i++) {
        var elem = document.getElementById('input' + i);
        if (elem === null)
            return null;  // Search Failed. No empty input found.
        if (elem.value === '') {
            elem.value = new_value;
            return elem;
        }
    }
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;重新组织你的代码&lt;/h2&gt;

&lt;h3&gt;分离不相关的子问题&lt;/h3&gt;

&lt;p&gt;工程师就是将大问题分解为一个个小问题，然后逐个解决，这样也易于保证程序的健壮性、可读性。如何分解子问题，下面给出一些准则：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;看看这个方法或代码，问问你自己“这段代码的最终目标是什么？”&lt;/li&gt;
&lt;li&gt;对于每一行代码，要问“它与目标直接相关，或者是不相关的子问题？”&lt;/li&gt;
&lt;li&gt;如果有足够多行的代码是处理与目标不直接相关的问题，那么抽离成子函数&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;来看一个例子：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ajax_post({
    url: 'http://example.com/submit',
    data: data,
    on_success: function (response_data) {
        var str = &quot;{\n&quot;;
        for (var key in response_data) {
            str += &quot;  &quot; + key + &quot; = &quot; + response_data[key] + &quot;\n&quot;;
        }
        alert(str + &quot;}&quot;);
        // Continue handling 'response_data' ...
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码的目标是发送一个&lt;code&gt;ajax&lt;/code&gt;请求，所以其中字符串处理的部分就可以抽离出来：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var format_pretty = function (obj) {
    var str = &quot;{\n&quot;;
    for (var key in obj) {
        str += &quot;  &quot; + key + &quot; = &quot; + obj[key] + &quot;\n&quot;;
    }
    return str + &quot;}&quot;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;意外收获&lt;/h4&gt;

&lt;p&gt;有很多理由将&lt;code&gt;format_pretty&lt;/code&gt;抽离出来，这些独立的函数可以很容易的添加feature，增强可靠性，处理边界情况，等等。所以这里，可以将&lt;code&gt;format_pretty&lt;/code&gt;增强，就会得到一个更强大的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var format_pretty = function (obj, indent) {
    // Handle null, undefined, strings, and non-objects.
    if (obj === null) return &quot;null&quot;;
    if (obj === undefined) return &quot;undefined&quot;;
    if (typeof obj === &quot;string&quot;) return '&quot;' + obj + '&quot;';
    if (typeof obj !== &quot;object&quot;) return String(obj);
    if (indent === undefined) indent = &quot;&quot;;

    // Handle (non-null) objects.

    var str = &quot;{\n&quot;;
    for (var key in obj) {
        str += indent + &quot;  &quot; + key + &quot; = &quot;;
        str += format_pretty(obj[key], indent + &quot; &quot;) + &quot;\n&quot;; }
    return str + indent + &quot;}&quot;;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个函数输出：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    key1 = 1
    key2 = true
    key3 = undefined
    key4 = null
    key5 = {
        key5a = {
            key5a1 = &quot;hello world&quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;多做这样的事情，就是积累代码的过程，这样的代码可以复用，也可以形成自己的代码库，或者分享给别人。&lt;/p&gt;

&lt;h4&gt;业务相关的函数&lt;/h4&gt;

&lt;p&gt;那些与目标不相关函数，抽离出来可以复用，与业务相关的也可以抽出来，保持代码的易读性，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;business = Business()
business.name = request.POST[&quot;name&quot;]

url_path_name = business.name.lower()
url_path_name = re.sub(r&quot;['\.]&quot;, &quot;&quot;, url_path_name) 
url_path_name = re.sub(r&quot;[^a-z0-9]+&quot;, &quot;-&quot;, url_path_name) 
url_path_name = url_path_name.strip(&quot;-&quot;)
business.url = &quot;/biz/&quot; + url_path_name

business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;抽离出来，就好看很多：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CHARS_TO_REMOVE = re.compile(r&quot;['\.']+&quot;)
CHARS_TO_DASH = re.compile(r&quot;[^a-z0-9]+&quot;)

def make_url_friendly(text):
    text = text.lower()
    text = CHARS_TO_REMOVE.sub('', text) 
    text = CHARS_TO_DASH.sub('-', text) 
    return text.strip(&quot;-&quot;)

business = Business()
business.name = request.POST[&quot;name&quot;]
business.url = &quot;/biz/&quot; + make_url_friendly(business.name) 
business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;简化现有接口&lt;/h4&gt;

&lt;p&gt;我们来看一个读写cookie的函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var max_results;
var cookies = document.cookie.split(';');
for (var i = 0; i &amp;lt; cookies.length; i++) {
    var c = cookies[i];
    c = c.replace(/^[ ]+/, '');  // remove leading spaces
    if (c.indexOf(&quot;max_results=&quot;) === 0)
        max_results = Number(c.substring(12, c.length));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这段代码实在太丑了，理想的接口应该是这样的：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set_cookie(name, value, days_to_expire);
delete_cookie(name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于并不理想的接口，你永远可以用自己的函数做封装，让接口更好用。&lt;/p&gt;

&lt;h4&gt;按自己需要写接口&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;ser_info = { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; }
user_str = json.dumps(user_info)
cipher = Cipher(&quot;aes_128_cbc&quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE)
encrypted_bytes = cipher.update(user_str)
encrypted_bytes += cipher.final() # flush out the current 128 bit block
url = &quot;http://example.com/?user_info=&quot; + base64.urlsafe_b64encode(encrypted_bytes)
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;虽然终极目的是拼接用户信息的字符，但是代码大部分做的事情是解析python的object，所以：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def url_safe_encrypt(obj):
    obj_str = json.dumps(obj)
    cipher = Cipher(&quot;aes_128_cbc&quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(obj_str)
    encrypted_bytes += cipher.final() # flush out the current 128 bit block
    return base64.urlsafe_b64encode(encrypted_bytes)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样在其他地方也可以调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user_info = { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; }
url = &quot;http://example.com/?user_info=&quot; + url_safe_encrypt(user_info)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;分离子函数是好习惯，但是也要适度，过度的分离成多个小函数，也会让查找变得困难。&lt;/p&gt;

&lt;h3&gt;单任务&lt;/h3&gt;

&lt;p&gt;代码应该是一次只完成一个任务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var place = location_info[&quot;LocalityName&quot;];  // e.g. &quot;Santa Monica&quot;
if (!place) {
    place = location_info[&quot;SubAdministrativeAreaName&quot;];  // e.g. &quot;Los Angeles&quot;
}
if (!place) {
    place = location_info[&quot;AdministrativeAreaName&quot;];  // e.g. &quot;California&quot;
}
if (!place) {
    place = &quot;Middle-of-Nowhere&quot;;
}
if (location_info[&quot;CountryName&quot;]) {
    place += &quot;, &quot; + location_info[&quot;CountryName&quot;];  // e.g. &quot;USA&quot;
} else {
    place += &quot;, Planet Earth&quot;;
}

return place;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这是一个用来拼地名的函数，有很多的条件判断，读起来非常吃力，有没有办法拆解任务呢？&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var town    = location_info[&quot;LocalityName&quot;];               // e.g. &quot;Santa Monica&quot;
var city    = location_info[&quot;SubAdministrativeAreaName&quot;];  // e.g. &quot;Los Angeles&quot;
var state   = location_info[&quot;AdministrativeAreaName&quot;];     // e.g. &quot;CA&quot;
var country = location_info[&quot;CountryName&quot;];                // e.g. &quot;USA&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先拆解第一个任务，将各变量分别保存，这样在后面使用中不需要去记忆那些繁长的key值了，第二个任务，解决地址拼接的后半部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Start with the default, and keep overwriting with the most specific value. var second_half = &quot;Planet Earth&quot;;
if (country) {
    second_half = country; 
}
if (state &amp;amp;&amp;amp; country === &quot;USA&quot;) {
    second_half = state; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再来解决前半部分：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var first_half = &quot;Middle-of-Nowhere&quot;;
if (state &amp;amp;&amp;amp; country !== &quot;USA&quot;) {
    first_half = state; 
}
if (city) {
    first_half = city;
}
if (town) {
    first_half = town; 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;大功告成：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return first_half + &quot;, &quot; + second_half;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果注意到有&lt;code&gt;USA&lt;/code&gt;这个变量的判断的话，也可以这样写：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var first_half, second_half;
if (country === &quot;USA&quot;) {
    first_half = town || city || &quot;Middle-of-Nowhere&quot;;
    second_half = state || &quot;USA&quot;;
} else {
    first_half = town || city || state || &quot;Middle-of-Nowhere&quot;;
    second_half = country || &quot;Planet Earth&quot;;
}
return first_half + &quot;, &quot; + second_half;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;把想法转换成代码&lt;/h3&gt;

&lt;p&gt;要把一个复杂的东西解释给别人，一些细节很容易就让人产生迷惑，所以想象把你的代码用平实的语言解释给别人听，别人是否能懂，有一些准则可以帮助你让代码更清晰：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;用最平实的语言描述代码的目的，就像给读者讲述一样&lt;/li&gt;
&lt;li&gt;注意描述中关键的字词&lt;/li&gt;
&lt;li&gt;让你的代码符合你的描述&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面这段代码用来校验用户的权限：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$is_admin = is_admin_request();
if ($document) {
    if (!$is_admin &amp;amp;&amp;amp; ($document['username'] != $_SESSION['username'])) {
        return not_authorized();
    }
} else {
    if (!$is_admin) {
        return not_authorized();
    } 
}
// continue rendering the page ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这一段代码不长，里面的逻辑嵌套倒是复杂，参考前面章节所述，嵌套太多非常影响阅读理解，将这个逻辑用语言描述就是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;有两种情况有权限：
1、你是管理员(admin)
2、你拥有这个文档
否则就没有权限
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;根据描述来写代码：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (is_admin_request()) {
    // authorized
} elseif ($document &amp;amp;&amp;amp; ($document['username'] == $_SESSION['username'])) {
    // authorized
} else {
    return not_authorized();
}
// continue rendering the page ...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;写更少的代码&lt;/h3&gt;

&lt;p&gt;最易懂的代码就是没有代码！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;去掉那些没意义的feature，也不要过度设计&lt;/li&gt;
&lt;li&gt;重新考虑需求，解决最简单的问题，也能完成整体的目标&lt;/li&gt;
&lt;li&gt;熟悉你常用的库，周期性研究他的API&lt;/li&gt;
&lt;/ul&gt;


&lt;h2&gt;最后&lt;/h2&gt;

&lt;p&gt;还有一些与测试相关的章节，留给你自己去研读吧，再次推荐此书：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;英文版：&lt;a href=&quot;http://book.douban.com/subject/5442971/&quot; title=&quot;The Art Of Readable Code&quot;&gt;《The Art of Readable Code》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;中文版：&lt;a href=&quot;http://book.douban.com/subject/10797189/&quot; title=&quot;编写可读代码的艺术&quot;&gt;编写可读代码的艺术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
    </entry>
    
    
    
    <entry>
        <title>给大学的同学们</title>
        <link href="http://www.soimort.org" />
        <updated>2012-11-30T00:00:00+08:00</updated>
        <id>http://www.soimort.org/to-myfriends</id>
        <content type="html">&lt;h2&gt;第一部分 —— 算不上写作缘由的缘由&lt;/h2&gt;

&lt;p&gt;　　同寝室的同学突然就离开了学校，去她女朋友那里了,说是出去散心了。
　　
　　事情的经过大概是这样的。这段时间有N多考试，N多作业，室友在图书管自习的时候，突然想大学快两年半的时间到底学到了什么，大学应该怎样得过，于是想了一下，就这样走了。当时我不在场，事情是后来听寝室老大说的，晚上学习了一天，筋疲力尽得回到寝室，本来期望寝室能够一片欣欣向荣的景象。老大却告诉寝室有一个人“走了”，第一反应是开玩笑，愣了两愣，但看到满床的杂物，是真的。
　　
　　他是很努力很认真的一个人，目标感比较清晰，悟性挺高，对事情的看法也比较深刻，看问题很本质的，平时也不会想太多乱七八糟的东西。我和他经常会在一块切磋一下什么的，有时也会一块儿出去旅行。虽然一直觉得大学会有一些人陷入迷茫，还有一些人从此一蹶不振了，但从来都没有感觉他是会迷茫的类型，总觉得他是大学里的少数那些目标明确，充满追求的人。
　　
　　看到室友就这么走了，想起了两年前的我。那时我也是迷茫且无助，啥也不知道。想到自己要出国，听说学分绩(GPA)很重要。于是像高中一样地傻学，结果大一的第一学期时候考试倒是真得考很好。但学着学着就迷茫了，觉得自己学的没有意义，考试有个屁用啊，又不能吃，后来就看了好多好多的书，做了好多好多的事情，去了好多好多的地方旅行，慢慢也就明白了好多东西了。其实这个过程是一个很漫长的过程，而且有些时候相当的痛苦，都是内心的挣扎，表面上过的挺好，内心啥也没有，觉得生活TMD的有啥意义啊！不过终归是破茧了，成蝶还谈不上，不过至少自己能看到阳光了，看到目标了，在加把劲就能飞出去了。这这漫长的过程就不说了，今天文章的重点不是说我自己。总之多看书，多见见世面，多思考，有点耐心终会走出来的。
　　
室友提出了几个问题就离开了,“大学到底学到了什么”和“大学应该怎样的过”。&lt;/p&gt;

&lt;p&gt;　　大学是怎么了？
　　
　　上了大学以后，很多同学发现大学并不是自己想象的那样。有好多人忍不住想问：大学到底是怎么了？关于这个问题我们可以从几个层次来分析。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;第一，大学真的应该是想象的那样的么？其实仔细想想就知道，当然不是的，现实跟每个人的想象都有一定的差距。你的所有推断都只能建立在你曾经的经历上面，而你自己的经验又是有局限的，这样你想象的大学当然就不是真的大学了。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　
　　第二，既然大学已经不是你想象的那样了，那大学是你现在看到的那样的么？关于这个问题，我觉的这个问题也是存在的。不同地方的大学都有不同的，就算是在同一所大学里，你在的学院不同感受到的大学氛围都是不一样的。（其实大学到底是什么样也不重要了,对于你来说，你的大学就是这样的了)
　　
　　第三，不同的大学总有共性的地方，这个共性的地方就是我们应该去探讨的。这个共性若是一个问题，大学的教育就真的是病了。
　　
　　总有人说中国的教育有问题，说什么强调应试，却没有人真正的提出来过说这到底是什么问题。我觉得中国教育的这个问题归根结底其实源头在于社会价值观上。而这个价值观集中的体现在了教育上面。大家也都慢慢地意识到了教育存在这样那样的问题，于是不停的教改，大学也在不停的改。我们恰恰处在这个不停地改革的浪尖上，不过改革目前也没有走对方向，或者至少只是解决了一些表面上的问题，所以目前大家包括我都还在这个病怏怏的大学里学习着。
　　
　　既然是病了，当然得对症下药，下药之前当然得知道大学到底出了什么样的的问题。我说的都是共性的东西，所以可能这些现象你的学校里可能没有，或者有一两个而有些不那么共性的现象你们的学校里有的没提到。但对于绝大多数同学来讲，就读的大学里或多或少都会存在下面的一些问题。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt; 大学里出来的人不具有一点点或者仅有一点点的实践能力。&lt;/li&gt;
&lt;li&gt; 大学里评价一个学生的优劣只通过一个标准。&lt;/li&gt;
&lt;li&gt; 大学成了高中的延伸，一样的考试，一样的应试教育。&lt;/li&gt;
&lt;li&gt; 大学里作弊风气严重，有时为了分数可以放弃很多原本比考试成绩更重要的东西。&lt;/li&gt;
&lt;li&gt; 对于大多数同学来说，学习的唯一的动力是考试，与考试无关的一切书籍一概不读，老师只要说了考试不考就一点兴趣都没有。&lt;/li&gt;
&lt;li&gt; 学校的活动大多偏重形式，没有实质意义。&lt;/li&gt;
&lt;li&gt; 学校不考虑人的兴趣因素，没有给学生自由发展的空间和从事自己爱好的自由。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;…………&lt;/p&gt;

&lt;p&gt;　　是不是发现自己的大学里都存在这样或那样的问题，知道了病症，也许可以看看有没有比较好的解决办法。&lt;/p&gt;

&lt;p&gt;　　好了，绕了一大圈。如果大家都是按着思路把文章看到了这里，而且觉得一切的分析都是那么的有条理而且清晰的话。那么恭喜你，你的大脑很正常，大家都是这么想的。（曾经的我自己就是这么想的。）&lt;/p&gt;

&lt;p&gt;　　后来我独自一人在自习的时候，发现这些看上去的问题都不是本质，培养素质和创造力根本就是扯淡。仔细想想，学校对于各个问题都有实行措施的，对于第一个问题，你发现学校多了很多实验课，实践课，实习课么，假期还多了社会实践。对于第二个问题，很多学校算入发展分，有的学校甚至试行过学生会主席直接保研的政策，对于第三个，第四个……问题是，这些政策真的的有用了么？执行成什么样了？有多少都流于形式了？&lt;/p&gt;

&lt;p&gt;　　后来在Positive Psychology里才知道。不是只有中国的学生才觉得迷茫，不是只有你这个学校才这样，全世界都是这样。这门课是哈佛大学上课人数最多的课程，开这门课程时他们做过一个有趣的统计，发现在哈佛大学里觉得不幸福的学生比例，跟美国任何一所高校都没有明显的区别。而Tal在亚洲的经历告诉了他，无论你是在美国，欧洲，还是亚洲；也无论你是在哈佛，牛津还是只在一个不知名的大学读书，你都面临着同样的问题。整个社会都有运转的的太快了趋势，于是愈来愈多的人没有时间去找到自己真正需要的东西，在起跑前甚至都没有时间去确定奔跑的方向。而在社会的大环境下，中国的大学教育和学术圈有这么一些个浮躁，做作，弄虚作假的情况出现也是正常的了。&lt;/p&gt;

&lt;p&gt;　　这样的环境中，我们作为每一个个体，在短期内是不能对教育环境做出巨大改变的，再说这些问题也都是表面的问题，再清的河里也还有泥呢。但我们还是能够是从自己身上去找一些问题，而这些比外界环境都更重要。&lt;/p&gt;

&lt;h2&gt;第二部分——所以请停下来感受生活吧&lt;/h2&gt;

&lt;p&gt;　　这部分，给大家讲两个故事吧，也许你能再里面找到一些停下来的原因。&lt;/p&gt;

&lt;p&gt;　　——————————————————————————————————&lt;/p&gt;

&lt;p&gt;　　阿成出生在一个家庭条件还算优越的家庭里。&lt;/p&gt;

&lt;p&gt;　　从他还在娘胎里的时候就受到了良好的教育，母亲从怀上他那天起，就每天听着各种各样优美的音乐，贝多芬的，肖邦的。在他出生以后，他吃上了家里能够找到的最好的奶粉，母亲给她买来各种各样的智力玩具，母亲如是说：不能让孩子输在起跑线上。后来，他到了上了幼儿园的年龄，母亲把他送到了一个双语幼儿园，他从小就接触到了良好的英语语言环境。&lt;/p&gt;

&lt;p&gt;　　再后来，他上了小学，良好的幼儿园教育由此给他带来了一些优势，但他想起母亲在上学前告诉他的话：“小学要好好念书，才能上一个最好初中。”于是他认真记住上课老师说的每一句话，回家以后认真完成了作业。每次考试都考的很好，才五年级的时候，就已经把小学的所有课程都学完了，而且他还在业余时间里坚持一直在学习英语。这年他参加了市里最好的初中的的选拔考试，顺利的考入了这所中学，母亲很开心，他觉得也许小学以来这么多年的辛苦值得了。&lt;/p&gt;

&lt;p&gt;　　后来他就进入了这所重点中学，母亲在他入学前再一次语重心长的对他说：“要好好上中学，将来才能考入一个好的高中。”他觉得很疑惑，为什么一定要去一个好的高中呢？母亲瞪大了眼睛：“只有进入好的高中，才能进入好的大学啊！”他看着母亲坚定的眼神，心想，母亲一定是对的。于是他认真记住上课老师说的每一句话，回家以后认真完成了作业，还自己做了很多题，每次考试都考得很好。当然，除了学英语以外，他在业余时间还参加了奥林匹克数学的培训，据说中考这个能够加分，特别优异的还能直接保送到省里最好的高中去。&lt;/p&gt;

&lt;p&gt;　　于是他毫无疑问的地进入了省里最好的高中，高中的生活依然如故，但他更努力了，最终他如母亲愿进入了全国顶尖的几所学府之一，并且就读于收分最高的金融专业。&lt;/p&gt;

&lt;p&gt;　　他进入了大学，却一下子失去了方向，因为这时候他没有母亲在告诉他怎么做了，他看到好多优秀的人，决定要给自己找到下一个目标。他想到了金融业的圣地Wall Street，于是他做出了生命中的第一个给自己定下的目标，目标是华尔街，然后他朝着这个目标，而且比以前还要努力。&lt;/p&gt;

&lt;p&gt;　　后来，他当然进入了华尔街。再往后的故事就不再赘述了，不外乎又是一个一个阿成不断的定下目标，然后又不断的去实现的过程。&lt;/p&gt;

&lt;p&gt;不过我想大家一定很关心阿成的结局吧。&lt;/p&gt;

&lt;p&gt;　　读者不需要怀疑，阿成最后当然是一个成功者。他工作在纽约最高大楼的最顶层，从那里它能够眺望全城的景色，而且那扇巨大的落地窗正对着最美的夕阳。这天，阿成觉得再也不能向上攀登了，他似乎已经到了这个行业的顶峰了。他终于有时间欣赏一下美景，这一切都是他拼搏了一辈子得来的。&lt;/p&gt;

&lt;p&gt;　　他在这个下午，接到了一个电话，是他秘书打来的：董事会考虑到他的年纪已经太大，而且他这几十年来对公司做出如此的巨大的贡献之后已经筋疲力尽，希望他可以提前退居二线，公司会由他们公司历史上最年轻的领袖来领导，他们也衷心希望这位新人能做的和他当年一样出色。&lt;/p&gt;

&lt;p&gt;　　——————————————————————————————————&lt;/p&gt;

&lt;p&gt;　　这个故事是Positive Psychology里的Tal Ben-shahar（泰·本·沙哈，那门课的老师）讲的一个故事的中国版，我在这里把阿成的故事讲给大家，实际上大家心目中的还有阿财，阿钱，阿名。他们从小就活在父母定下的目标里，有些尽管活在自己定下的目标中，但其实，这些目标是社会给他们定下的，或者是老师定下的，他们心里以为是自己的目标，殊不知其实他们已经被institutionalized（《肖申克的救赎》里老布说的一个词，意思是制度化的）了。&lt;/p&gt;

&lt;p&gt;　　Tal自己也有一个阿成故事的版本，不过文章的主角变成了他自己，而金融界的公司变成了他对壁球的追求。他说他拿了全国冠军的那天，只开心了不到6个小时，到了那个晚上，剩下的只有空虚。从那之后他就慢慢得开始考虑关于幸福的问题了。&lt;/p&gt;

&lt;p&gt;　　这部分人在Tal研究的积极心理学里有一个名字叫做“追名逐利者”。他们的人生追求全部都建立在对社会固有价值体系中的so-called（所谓的）成功的追求上面，并且希望人生轨迹是一条笔直的直线。&lt;/p&gt;

&lt;p&gt;　　第二个故事是关于几台计算机的，这是一篇博文里的小故事，我将大意在这里转述吧。
　　——————————————————————————————————
　　我们每个人，都像高速运转的一台计算机，而且一代比一代跑得快。
　　这些计算机都生活在一个机房里，每天跑着程序员写好的程序。上高中，上大学，找工作，买房买车。
　　故事就是这样的开始的。
　　在这个机房，有一台名字很长编号很长的计算机(以下简称A)突然停了下来，因为他觉得很郁闷，为什么他只能跑别人给他写好的程序，他希望能够跑自己写的程序。于是他停了下来。这台计算机开始是跑在前面的，但是他停了，所以他很快就被超了过去。更令他痛苦的是，尽管从出生到现在他跑了一辈子的程序，但等他突然想要跑自己的程序的时候，发现自己压根就不会写程序。他现在有两个选择，当成自己刚才是宕机了，抓紧时间可以把刚才浪费的时间补回去。或者，停下来选择靠自己来自学编程。
　　他选择了靠自己来学习编程。跟他一块儿停下来的还有几台机器，也发现自己不会写程序，看着自己领先的地位慢慢丢掉，想了想:还是不去学编程了，继续算下去吧，虽然浪费了这些时间，但只要重新振作就又能算到前面去。
　　A觉得很无奈，而且看着自己从机房的计算排行榜里的前几名慢慢地掉到后面去几名去，他就觉得更无奈了，可是他还是很坚定地想跑自己的程序。为此他只好一个人去学习编程，没有人教他，他只有慢慢地去摸索。他花了几个月，也许是一年，忍受着孤独和寂寞，学会了自己编程序。又花了几个月，或者是很长的时间，才学会运行自己的程序。后来，A一直是机房里唯一一台跑着自己程序的机器。
　　这就是为什么世界上只有那么少的计算机在跑自己写的程序的原因。
　　——————————————————————————————————
　　好了，上面只是两个故事，个中道理还是希望大家自己去慢慢领悟，也许那些给你跑程序的既不是你的父母也不是你的老师或亲人，但你还是跑着别人的程序。
　　如果决定像A一样你停了下来，请一定要努力去坚持。故事里的A尽管停了下来，却又再次迷失了，因为要想重新启航，必须要经过一个自己编程序的过程。这个过程需要你有强大的内心。
　　说完两个故事，只是想给大家一点停下来里的理由，对于不同的人，都有对于自己的不同的理由。在找到自己的方向之前，先适当的停下来，就像我第二部分的标题：停下来是为了更好的启程。&lt;/p&gt;

&lt;p&gt;————————————————————————
——第三部分——停下来是为了更好地重新启程———
————————————————————————
　　如果你只是随便看看选择读一段的话，我希望是下面这一段。关于体验，选择，梦想与追求。&lt;/p&gt;

&lt;p&gt;　　选择与体验。
　　关于选择，台湾的一位教授的曾经提到一段话很有道理。他说人生会有无数的选择，当你纠结的时候，哪一个选择都不重要，因为人生太长，而这两条路差不多，任何一条路都不会让你走的太远，就算你走偏了，下次选择就是你纠正的机会。我十分赞成这个观点，但是有一个问题，就是如果你都没有目标怎么办，又或者，你的目标其实是别人给你定下的，选择什么还将直接决定你的体验。我在后面一段会提到怎么确定你的目标，这里先不讲。
　　Positive Psychology中提到了一个研究成果：一个人的幸福是有一条中位线的。无论你获得了什么开心的事情诸如中了500万或是获得了万众瞩目的成就,最终你的幸福指数还是会回归到你的中位线上去；失败亦然，就算一天大的灾难，只要你还活着，你的幸福感就会回归到你的幸福线上面去。相信大家也都有这样的经历，无论你那段时间多么的难过，最终你还是慢慢变开心了，又回到你的中位线上去。所以你的成功还是失败与否都和你这个人的总的幸福指数没有一丁点关系。不过那里面也提到另一条结论，你的中位线是可以被提高的，而这个提高的办法就是try，bravely and out your comfort zone。翻译过来就是不断地去尝试，离开自己的安乐窝，勇敢的去尝试。
　　体验最终会成为一个人的阅历，常常听人说：“不听老人言，吃亏在眼前。”这句话的道理就是这个。玩游戏的也知道有一个叫“经验”的东西和级别有关，只有多打怪多积累经验才能Level Up。级别不够，经验不够，是没有机会挑战最终Boss的。
　　很多事情，在体验之前知道的只是道理，因此即使你有完美的理论，你也无法说服一个跟你体验不同的人。就好像北方人希望告诉一个一直生活在南方从来没有见过下大雪的人，北方的大雪下大了相当得恼人。尽管你有充足的事实和新闻报道，你还是无法说服南方的孩子，他们即使理智上相信了，内心也还是以为，雪是美丽的精灵。
　　所以我的建议是，在你犹豫的的时候，去选择那个新的选择，过去的那种生活你已经知道了。不断的去尝试新的生活。去打架，去奋斗，去旅行，去抛弃一切地追求自由，去撕心裂肺的哭，去感动，去听音乐会，甚至去打架，一切你好奇的，未知的，你想去探索的都去尝试。就像上面第一个故事里的阿成，如果你只是像他一样的过了那么多年，那你实际上只过了一种生活，你每天，每星期，每个月，甚至每一年的都是差不多的事情，明年的你只是比今年又老了一年罢了。
　　如果你选择了去尝试另一种生活方式，明年的你就将和今年一样年轻，你只是比别人多了一份生活的体验，多了一年的阅历，一切都想一年前一样新鲜和有趣。趁你还年轻，多去积累经验和阅历，多练级，这些体验都会在你为你的目标开始奋斗的时候成为你的财富。&lt;/p&gt;

&lt;p&gt;　　梦想和目标。
　　关于梦想。我第一时间会想到一个人。
　　这个人，我想先讲讲他的故事。
　　——————————————————————————————————
　　美国很多高校都会安排学校的资深教授在退休前向全校学生的做一次公开的演讲，作为他们教学生涯的“最后一课”，用来表达学校师生对他们的崇敬和感激，也让教授为自己的教学生涯划上一个完美的句号。
　　在2007年9月18日，卡耐基梅隆大学（Carnegie Mellon University）大学里，一场题为“Really Achieve Your Childhood Dream（真正实现你的童年梦想）”的演讲却引起了旋风般的反应。。演讲的视频片断在网上播出后，数以千计的人同他联系，表示他给他们的生活带来了深刻影响。这场演讲是的主讲是兰迪·波许(Randy Pausch)，对于他来讲，这真的是一场非同寻常的“人生最后一场演讲”。
　　早在2006年9月，兰迪就被诊断患有胰腺癌，尽管进行了手术和化疗，他还是在2007年8月被告知癌细胞已经转移至肝脏及脾脏，只能再活3至6个月。时隔一个多月，他作出了一个影响全世界读者的决定：在自己的母校，他生前所供职的大学卡耐基梅隆上演自己“最后的演讲”。
　　在演讲中，兰迪·波许教授告诉观众永远不要放弃梦想，当面对困难时他说“但请记住，阻挡你的障碍必定有其原因！这道墙并不是为了阻止我们，这道墙让我们有机会展现自己有多想达到这目标。这道墙是为了阻止那些不够渴望的人，它们是为了阻挡那些不够热爱的人而存在。”
　　兰迪这次演讲的题目叫做“Really Achieve Your Childhood ”,小时候他的梦想是在嘉年华会上赢得超大型的动物玩偶，体验无重力的环境，参加全国橄榄球联盟的比赛，当星际迷航记中的库克船长，写一篇百科全书的文章，以及加入迪斯尼梦幻工程队设计迪斯尼乐园的云宵飞车。最令人惊讶也令人羡慕的是，兰迪这些儿时的梦想后来竟然大部分都实现了。 在生命的尽头，兰迪·波许最后一次接受了《华尔街日报》记者杰夫·萨斯洛的采访。这一次采访，兰迪·波许把所有的焦点都锁定在了关爱上。对于兰迪·波许这个知道自己仅剩不多时日的人来说，有太多太多想要挽留、想要与家人朋友分享的东西。最后，他选择了以视频资料的方式把一个爸爸的背影留给3个孩子，最大的也不过7岁的3个孩子。“孩子，比谁都需要知道父母对他们的爱，如果他们的父母不能再活下去的时候。” 　　
　　对于一个健康的人来说，半年的概念也许就是学生的一个学期，或者从春天到夏天的季节变化。但对于兰迪·波许来说，这比什么都珍贵。或许是因为医学的奇迹，或许是因为兰迪·波许开阔的心态，兰迪·波许不仅活过了院方通知的6个月，还活到了2008年7月25日，即自那次“最后的演讲”起的第11个月，比预期整整多活了半年。 　　
　　尽管兰迪·波许最终还是离开我们了，但那场演讲通过文字、音频、视频留在了我们的视线之内。《华尔街日报》记者杰夫·萨斯洛后来在一篇报道中谈起第一次采访兰迪·波许的情况。“我第一次和他在电话上聊上是在他发表演讲的前一天。他的话语非常地振奋人心，以至于我非常想要看到他在台上到底是什么样子。后来的谈话我觉得有点白痴，我不知道怎么去跟一个即将辞世的人说话，但是兰迪却能找到让话题兴奋起来的闪光点。那时候他正开着他的车，用手机跟我聊，我怕他出交通事故，所以建议他把车靠边，我们再聊。但他却笑了：‘嘿，如果我死于车祸，那会有什么不同？’” 　　
　　在卡内基·梅隆大学的网站上，兰迪·波许开有自己的个人主页。自从2006年9月兰迪·波许被诊断出患有胰腺癌之后，他就会定期在主页上更新他最近的状况。从这些更新中，我们就能看出这位开朗的教授如何以开朗的心态看待自己，比如2007年4月2日标题为《回来继续战斗》的更新。 　　
　　全世界有很多人被感动，并不仅仅是因为兰迪·波许所做出的成就而感动，也不仅仅是因为他最后的演讲，更重要的是他顽强的意志力，他与癌症抗争的信念和他对生活“心存感激，心存包容”的乐观态度。
　　(注：以上文字改写自中文维基，百度百科和李开复《引领你的一生》)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ——————————————————————————————————
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;　　这个演讲留给我这样一句话。&lt;/p&gt;

&lt;p&gt;　　Let Your Dream Lead Your Life.
　　他的这一生就是沿着追寻他梦想的轨迹在前进的，最终实现他童年的那些即使是很荒诞的梦想。对于那些还记得自己梦想的人来说，我觉的最好的一个生活态度就是就是“Dream Lead Life”，那是一个灯塔，指引着你前进。
　　对于有梦想的人来说，梦想当然可以成为他们的目标，但是对于另外的一部分人（可以说是很多人）觉得自己是没有梦想的，或者他们已经活到忘记了自己的梦想是什么了，他们应该怎么做呢？
　　前面说过做出选择也是和目标是有关的，我给大家带来了一个方法，我接触它是由于一封朋友的邮件，里面提及相关的一篇文章带来的这个方法。而个方法再往前，能够追溯到一位知名写手Steve Pavlina的博客上，但这个方法貌似也不是他自己发明的。
　　网上一些关于这个文章的翻译，但看了一下大部分翻译都漏掉或者错掉了一些地方，我推荐有一定英语功底的同学直接看原文。
　　英语不好的同学，我在这里转述一下吧。
　　首先你需要找到一个小时或者更长的完全属于自己的时间，排除外界的一切干扰，最好是关掉手机，有条件的可以关掉房门，在一个你能够安心和自己呆在一起的地方。这个测试也许会花掉你二十分钟，也许是一个小时，因人而异。
　　在你找到一个属于只有自己的时间和环境以后。就可以开始了，这个方法被Steve Pavlina归纳成了四步。&lt;/p&gt;

&lt;p&gt;　　——————————————————————————————————
　　1.Take out a blank sheet of paper or open up a word processor where you can type.
　　2.Write at the top, “What is my true purpose in life?”
　　3.Write an answer (any answer) that pops into your head. It doesn’t have to be a complete sentence. A short phrase is fine.
　　4.Repeat step 3 until you write the answer that makes you cry. This is your purpose.
　　——————————————————————————————————
　　1.第一步是让你准备一张或者几张大的白纸，或者打开类似word的文字处理器。我更倾向与前者，因为纸笔对于我们学生来说，都比软件更亲切许多，而且更容易让你静下来。
　　2.接下来是让你在纸的顶部或者文档的顶部写上：“我这辈子活着是为了什么？”
　　3.是的，这一步是让你回答之前的那个问题。这个答案不必是一个完整的句子，几个字都行。比方说：吃很多好吃的。
　　4.不断的重复第三步，直到你哭出来。
　　——————————————————————————————————
　　就这么简单，这个方法看上去很傻，但是很有效。
　　当你找到一个属于内心的独一无二的答案时，你会感觉到它会与你产生深深的共鸣。每一个词语对你仿佛都充满了力量，当你读这句话的时候，你会感觉充满了力量。就是这样一句话，对你来说会充满特别的意义。
　　对于一些人，这个测试可能会持续很长的时间，一个小时或者更长，尤其对是那些很少思考这类问题的同学。你可能一开始就觉得这个测试很傻，或者没有效果，没有关系，这都无所谓，你尽管去做就是了，你和那些一开始就相信这个测试有效的人一样都会得到结果，最多是你比他们多花一些时间。最终的那个时刻会出现的，这一个小时会成为你人生中最重要的时刻之一。
　　另外，如果你觉得你是一个虚无主义者，没有任何追求的话，你也可以在最开始的地方写上：“我的人生没有任何意义。”写下的答案可以仅仅是一个瞬间的想法，可以是你想到的任何一个答案，尽管这个答案对你来说可能没有任何意义，你还是可以把它写上去，这样有利于捕捉你心里的每一个微小的想法。
　　对于绝大多数人，你可能是将信将疑的态度，大概在50步以及以后的一段时间会有想放弃的感觉，你会想去做一些别的什么事情。这时请不要放弃，你只是需要先把把脑子里面的那些杂物剔除掉，如果你坚持下去，在100步到200步左右的时候，就开始有感情涌向胸口了，但是这时候你还没有想哭的感觉，你需要坚持写下去，并且把那些你觉得重要的答案做好标记以便后来查看，坚持写下去，最终会出现你想要的答案的，它可能是你前面的几个答案的组合或者升华。最终的那个答案出现的时候，会使这一个小时会成为你人生中最重要的时刻之一。
　　Steve Pavlina在做这个的练习的时候，花了大概25分钟的时间，在第106步找到了他的最终答案。第17，39，53步的答案都让他有一阵情感涌动。他将这些答案抽出重新排列，最后在第100步到第106步答案得到了升华。想要放弃的感觉出现在他的第55到60步，他写到第80步的时候，他休息了2分钟，闭上眼，放松大脑，然后重新整理自己的思绪。
　　如果你要和我来比较的话，我在第33步，第45步，和第51步的时候，都有一种很强烈的感情涌出，在92步的时候，而最后止步的第113步是一个很长很长的句子。我在很早之前就一直在思考自己的人生目标，而且做这个测试之前就一直比较清晰，所以当最后得出的答案和自己一直以来的答案有一番神似，而且真的让自己有一种哭出来的冲动的时候，也觉得相当的惊讶。
　　最终你得到的答案，会是你从小到大的经历的整合，包含了你的回忆，你的价值观，你的梦想，你从出生到现在的所有的选择和体验的，因为你花了一个小时甚至更多的时间去思考和体会，只和你自己有交流，这是你自己一切经历沉淀的结果。你的答案可能在别人看来会很空洞，但是对于你自己来说却有源源不断的力量。
　　这个答案绝对不是你探求的全部，它会是一个起点。我更希望你新的启航能够围绕着这个答案去奋斗和理解。也要尽全力的更多的去体验和阅读。思考，体验和阅读永远是你成才的最根本的途径，也才能真正去理解更多的东西。就向在体验那节里说的，有些事情只有自己亲自试过了，才会真正懂得。&lt;/p&gt;

&lt;p&gt;————————————————————————
———第四部分——算不上结尾的结尾———————
————————————————————————&lt;/p&gt;

&lt;p&gt;后记&lt;/p&gt;

&lt;p&gt;　　其实文章酝酿了很久，好早之前，就希望自己的一些体悟能够帮到一些什么人。曾几何时，我也在想我大学到底学到了什么，到底有什么意义。
　　大三的同学可能都还只有时间忙学习和保研，但大四面临抉择的时候，会有更多的人陷入困境里。在将来的某次选择上，某一天，你忙过之后，也许会醒悟到原来之前的所有耳耳都是浮云。
　　文章初衷是想我的室友能够从中借鉴到一些东西，但后来我更希望它能帮到每一个人，也许你现在还处在一个懵懂的时期，还没开始思考关于生命的东西，但无论你现在是不是迷茫，是否还在纠结出国，保研，工作的选择。也许你感觉自己是目标清晰的仍然在奋斗着，我仍然希望你能从这篇文章中获得一些体味。文章不是一篇说理文，也不是一篇说教文，只是希望能够分享一些我自己思考的结果并因此帮到一些人。如果你愿意，你也可以把这篇文章分享给更多的人。
　　所有的想法，所有的经验，都是我亲生经历所得出来的，当然也会有个人的局限。文中所讲，整理了很多我这两年期间的阅读和体验。大部分时间都在思考一个简单的问题：人生目标。我在大学里花了半个学期的时间去给一个培训机构打工，花了半个假期的时间独自一人出国旅行了一遭，在假期和学期间走了中国的很大一部分省会城市以及周边的一些小城市，剩下的时间用来阅读和完成学业上的一些东西。
　　一些我觉得很有价值的东西，我把它们列在后面，作为附录，也算是送给大家的礼物。就像我在体验那段里说的，不是我在这里说了什么重要的，而是你体验了什么东西重要。所以我相信在你用心体验完附录里的的这些之后，你会再成长很多。&lt;/p&gt;

&lt;p&gt;————————————————————————
————附录——算不上礼物的礼物————————
 —————————————————————————————————— ————————————————————————&lt;/p&gt;

&lt;p&gt;　　% Positive Psychology——Harvard的公开课，豆瓣有一个小组是关于这个的，有豆友评论说这是一门能够改变人生的课程，我觉得这门课能让你更好的跟自己交谈，知道自己生命中什么重要，什么不重要。
　　% The Last Lecture——第一次是在《读者》上看到李开复推荐这个，关于文中曾经提到过的Randy这人的最后一次演讲。Let Your Dream Lead Your Life这句话也因此影响了我在那之后的每一个选择，所以说阅读有些时候可以改变人的一生。
　　%《野火集》龙应台——台湾一女作家的集子，我花了一个下午就看完了，也许你对现在的中国会有一个更深刻的理解了。
　　%《浪潮之巅》吴军——这本书只推荐学IT和金融的同学，看了以后你对现在整个世界的高新技术经济体系会有一个比较系统的了解。
　　%《生命不能承受之轻》米兰昆德拉——米兰昆德拉最著名的作品，文章有虽然很多露骨的描写，但这本书在有了一些人生阅历再去，阅读以后会感觉跟之前有很大的区别
　　%《病隙碎笔》史铁生——史铁生是一个很体贴读者的作家，他的东西总是很深入浅出，他的经历让他比所有其他人都更有资格去谈人生，除了这本，我推荐有空去也去他的其他书。
　　%《太傻十日谈》黄果,陶奇——尽管这本书其真实性和炒作性我不能保证，毕竟太傻从论坛到现在已经相当的商业化了，但这本书里的很多道理都是很实在也很现实的，所以打算出国的同学，好好想一下自己为什么要出国吧
　　%《出国自助游教室》三少——推荐这本书有没有让很多人觉得意外，这本书没有一点点指导人生的东西在里面，都是出国的经验在里面。不过三少本人倒是很坚持让学生出去旅行，外面的世界很大，请不要以为你见到的世界就是全部，也不要一到假期就奔向旅游点了。相信我，包含探寻和思考的旅行会有很多的收获。更何况，出国比你想象的容易，当你独自一人踏上异国土地的时候，会感觉如获新生。
　　%《生命是长期而持续的累积》——文章提到台湾教授的那篇关于选择的文章
　　%《给明年依然年轻的我们：欲望、外界、标签、天才、时间、人生目标、现实、后悔、和经历》——同学给我的邮件里的博文，里面提到了我文中的那个故事和我说的那个找到目标的方法&lt;/p&gt;

&lt;!--&lt;iframe height=&quot;498&quot; width=&quot;510&quot; src=&quot;http://player.youku.com/embed/XNTUxNDY1NDY4&quot; frameborder=&quot;0&quot; style=&quot;margin:0 auto&quot;&gt;&lt;/iframe&gt;--&gt;



</content>
    </entry>
    
    
</feed>
