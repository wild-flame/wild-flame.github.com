<!DOCTYPE html>
<html itemscope itemtype="http://schema.org/Blog">
<head>
    <meta charset="UTF-8" />
    <meta name="application-name" content="Looking-Glass" />
    <meta name="author" content="David Lin" />
    <meta name="generator" content="Jekyll 1.0.2" />
    <meta name="description" content="将《The Art of Readable Code》的读书笔记和一点自己的认识总结起来写就这么一篇博客，强烈推荐此书。" />
    <meta name="keywords" content="" />
    <meta itemprop="name" content="编写可读代码的艺术" />
    <meta itemprop="description" content="将《The Art of Readable Code》的读书笔记和一点自己的认识总结起来写就这么一篇博客，强烈推荐此书。" />
    <meta itemprop="image" content="/images/m.png" />
    <title>David Lin | 编写可读代码的艺术</title>

    <link rel="alternate" type="application/atom+xml" href="/atom.xml" />
    <link rel="icon" type="image/vnd.microsoft.icon" href="/favicon.ico" sizes="57x57" />
    <link rel="author" type="text/html" href="wild-flame.github.io" />
    <link rel="license" type="text/html" href="http://creativecommons.org/licenses/by-sa/3.0/" />
    
    <!-- Google Web Fonts (not in use) -->
    <!-- link rel='stylesheet' type='text/css' href='http://fonts.googleapis.com/css?family=Droid+Sans' / -->
    
    <link rel="stylesheet" type="text/css" href="/css/main.css" media="all" />
  
    <link rel="stylesheet" type="text/css" href="/css/mobile.css" media="all and (max-width:1023px)" >
    
    <!-- Highlight.js -->
    <link rel="stylesheet" href="/css/tomorrow-night.min.css">
    <script src="/js/highlight.pack.js"></script>
    <!-- script>hljs.initHighlightingOnLoad();</script -->
    
    <!-- Pygments -->
    <link rel="stylesheet" type="text/css" href="/css/pygments.css" media="all" />
    
    <!-- jQuery & Galleria -->
    <script src="http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.js"></script>
    <script src="/plugins/galleria/galleria-1.2.8.min.js"></script>
    
    <!-- MathJax (not in use) -->
    <!-- script type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
        });
    </script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script -->
    
    <!-- ShareThis (not in use) -->
    <!-- script type="text/javascript" src="http://w.sharethis.com/button/buttons.js"></script>
    <script type="text/javascript">stLight.options({publisher: "9aabed9c-ac3f-4f96-8f5a-8e7a27307543"}); </script -->
    
</head>

<body>
    <!-- load background image (must be put in body) -->
    <script type="text/javascript">
        document.body.style.backgroundImage = "url('http://www.goodfuneralguide.co.uk/wordpress/wp-content/uploads/2012/01/Candle_flame_by_Zhenia1994.jpg')";
    </script>
    
    <nav id="navBarTop">
        <ul class="navBarListLeft">
            <li><a href="/"><img src="/images/home.png" alt="home" title="Home" class="navDock" height="32" /></a></li>
            <li><a href="/atom.xml" target="_blank"><img src="/images/feed.png" alt="feed" title="Feed" class="navDock" height="32" /></a></li>
            <!--span id="spanBadges">
                <li style="position: relative; top: -12px; font-size: 16px"><code>(badges</code></li>
                <li style="position: relative; top: 0px; font-size: 16px" id="coderwall"></li>
                <li style="position: relative; top: -12px; font-size: 16px"><code>)</code></li>
            </span Not in use--> 
            <li style="position: relative; top: -12px; font-size: 16px"><a href="/" title="Hello world!" target="_blank">Code: Growing & Giving</a></li >
        </ul>
        
        
<ul class="navBarListRight">
            <li style="position: relative; top: -12px"><b>David Lin</b> on </li>           
            <!-- Facebook --><li><a href="http://www.facebook.com/lindongwen" target="_blank"><img src="/images/facebook.png" alt="facebook" title="Facebook" class="navDock" height="32" /></a></li >
            <!-- GitHub --><li><a href="http://github.com/wild-flame" target="_blank"><img src="/images/github.png" alt="github" title="GitHub" class="navDock" height="32" /></a></li>
        </ul>
    </nav>
    
    <nav id="navBarBottom">
        <div class="navBarListLeft">
            <a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank"><img src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" height="28" alt="CC BY-SA 3.0 License" title="CC BY-SA 3.0 License" /></a>
            <br />
            <div style="position: relative; top: 4px; width: 60%">
                © 2013 <a href="http://wild-flame.github.io/" target="_blank"><b>Wildflame</b></a>. Unless otherwise stated, all contents on this site are released under a <a href="http://creativecommons.org/licenses/by-sa/3.0/" target="_blank"><b>CC BY-SA 3.0 License</b></a>.
            </div>
        </div>
        
        <div class="navBarListRight">
            <a href="http://www.w3.org/html/logo/" target="_blank" style="position: absolute; right: 0"><img src="http://www.w3.org/html/logo/badge/html5-badge-h-css3-semantics.png" height="36" alt="HTML5 Powered with CSS3 / Styling, and Semantics" title="HTML5 Powered with CSS3 / Styling, and Semantics" /></a>
            <br />
            <div style="position: relative; top: 20px; right: 0">
                Powered by <a href="http://jekyllrb.com/" target="_blank"><b>Jekyll</b></a> & <a href="https://github.com/soimort" target="_blank"><b>Mort</b></a> 
            </div>
        </div>
    </nav>
    
    <div id="divTitle">
    <h1>编写可读代码的艺术</h1>
    <p><div class="g-plusone" data-size="medium" data-annotation="none"></div></p>
    <p><b>21 Mar 2013</b>, by <b>David</b></p>
    <p>将《The Art of Readable Code》的读书笔记和一点自己的认识总结起来写就这么一篇博客，强烈推荐此书。</p>
</div>

<div id="divPost">
    <article id="articlePost">
        <p>这是《The Art of Readable Code》的读书笔记，再加一点自己的认识。强烈推荐此书：</p>

<ul>
<li>英文版：<a href="http://book.douban.com/subject/5442971/" title="The Art Of Readable Code">《The Art of Readable Code》</a></li>
<li>中文版：<a href="http://book.douban.com/subject/10797189/" title="编写可读代码的艺术">编写可读代码的艺术</a></li>
</ul>

<h2>代码为什么要易于理解</h2>

<blockquote>
<p>&quot;Code should be written to minimize the time it would take for someone else to understand it.&quot;</p>
</blockquote>

<p>日常工作的事实是：</p>

<ul>
<li>写代码前的思考和看代码的时间远大于真正写的时间</li>
<li>读代码是很平常的事情，不论是别人的，还是自己的，半年前写的可认为是别人的代码</li>
<li>代码可读性高，很快就可以理解程序的逻辑，进入工作状态</li>
<li>行数少的代码不一定就容易理解</li>
<li>代码的可读性与程序的效率、架构、易于测试一点也不冲突</li>
</ul>

<p>整本书都围绕“如何让代码的可读性更高”这个目标来写。这也是好代码的重要标准之一。</p>

<h2>如何命名</h2>

<h3>变量名中应包含更多信息</h3>

<h4>使用含义明确的词，比如用<code>download</code>而不是<code>get</code>，参考以下替换方案：</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text"> send -&gt; deliver, dispatch, announce, distribute, route
 find -&gt; search, extract, locate, recover
start -&gt; lanuch, create, begin, open
 make -&gt; create,set up, build, generate, compose, add, new
</code></pre></div>
<h4>避免通用的词</h4>

<p>像<code>tmp</code>和<code>retval</code>这样词，除了说明是临时变量和返回值之外，没有任何意义。但是给他加一些有意义的词，就会很明确：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">tmp_file = tempfile.NamedTemporaryFile() 
...
SaveData(tmp_file, ...)
</code></pre></div>
<p>不使用retval而使用变量真正代表的意义：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">sum_squares += v[i]; // Where&#39;s the &quot;square&quot; that we&#39;re summing? Bug!
</code></pre></div>
<p>嵌套的for循环中,<code>i</code>、<code>j</code>也有同样让人困惑的时候：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">for (int i = 0; i &lt; clubs.size(); i++)
    for (int j = 0; j &lt; clubs[i].members.size(); j++)
        for (int k = 0; k &lt; users.size(); k++) if (clubs[i].members[k] == users[j])
            cout &lt;&lt; &quot;user[&quot; &lt;&lt; j &lt;&lt; &quot;] is in club[&quot; &lt;&lt; i &lt;&lt; &quot;]&quot; &lt;&lt; endl;
</code></pre></div>
<p>换一种写法就会清晰很多：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"> if (clubs[ci].members[mi] == users[ui])  # OK. First letters match.
</code></pre></div>
<p>所以，当使用一些通用的词，要有充分的理由才可以。</p>

<h4>使用具体的名字</h4>

<p><code>CanListenOnPort</code>就比<code>ServerCanStart</code>好，can start比较含糊，而listen on port确切的说明了这个方法将要做什么。</p>

<p><code>--run_locally</code>就不如<code>--extra_logging</code>来的明确。</p>

<h4>增加重要的细节，比如变量的单位<code>_ms</code>，对原始字符串加<code>_raw</code></h4>

<p>如果一个变量很重要，那么在名字上多加一些额外的字就会更加易读，比如将<code>string id; // Example: &quot;af84ef845cd8&quot;</code>换成<code>string hex_id;</code>。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">             Start(int delay)  --&gt;  delay → delay_secs
        CreateCache(int size)  --&gt;  size → size_mb
ThrottleDownload(float limit)  --&gt;  limit → max_kbps
          Rotate(float angle)  --&gt;  angle → degrees_cw
</code></pre></div>
<p>更多例子：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">password  -&gt;  plaintext_password
 comment  -&gt;  unescaped_comment
    html  -&gt;  html_utf8
    data  -&gt;  data_urlenc
</code></pre></div>
<h4>对于作用域大的变量使用较长的名字</h4>

<p>在比较小的作用域内，可以使用较短的变量名，在较大的作用域内使用的变量，最好用长一点的名字，编辑器的自动补全都可以很好的减少键盘输入。对于一些缩写前缀，尽量选择众所周知的(如str)，一个判断标准是，当新成员加入时，是否可以无需他人帮助而明白前缀代表什么。</p>

<h4>合理使用<code>_</code>、<code>-</code>等符号，比如对私有变量加<code>_</code>前缀。</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var x = new DatePicker(); // DatePicker() 是类的&quot;构造&quot;函数，大写开始
var y = pageHeight(); // pageHeight() 是一个普通函数

var $all_images = $(&quot;img&quot;); // $all_images 是jQuery对象
var height = 250; // height不是

//id和class的写法分开
&lt;div id=&quot;middle_column&quot; class=&quot;main-content&quot;&gt; ...
</code></pre></div>
<h3>命名不能有歧义</h3>

<p>命名的时候可以先想一下，我要用的这个词是否有别的含义。举个例子：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">results = Database.all_objects.filter(&quot;year &lt;= 2011&quot;)
</code></pre></div>
<p>现在的结果到底是包含2011年之前的呢还是不包含呢？</p>

<h4>使用<code>min</code>、<code>max</code>代替<code>limit</code></h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">CART_TOO_BIG_LIMIT = 10
    if shopping_cart.num_items() &gt;= CART_TOO_BIG_LIMIT:
        Error(&quot;Too many items in cart.&quot;)

MAX_ITEMS_IN_CART = 10
    if shopping_cart.num_items() &gt; MAX_ITEMS_IN_CART:
     Error(&quot;Too many items in cart.&quot;)
</code></pre></div>
<p>对比上例中<code>CART_TOO_BIG_LIMIT</code>和<code>MAX_ITEMS_IN_CART</code>，想想哪个更好呢？</p>

<h4>使用<code>first</code>和<code>last</code>来表示闭区间</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">print integer_range(start=2, stop=4)
# Does this print [2,3] or [2,3,4] (or something else)?

set.PrintKeys(first=&quot;Bart&quot;, last=&quot;Maggie&quot;)
</code></pre></div>
<p><code>first</code>和<code>last</code>含义明确，适宜表示闭区间。</p>

<h4>使用<code>beigin</code>和<code>end</code>表示前闭后开([2,9))区间</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">PrintEventsInRange(&quot;OCT 16 12:00am&quot;, &quot;OCT 17 12:00am&quot;)

PrintEventsInRange(&quot;OCT 16 12:00am&quot;, &quot;OCT 16 11:59:59.9999pm&quot;)
</code></pre></div>
<p>上面一种写法就比下面的舒服多了。</p>

<h4>Boolean型变量命名</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">bool read_password = true;
</code></pre></div>
<p>这是一个很危险的命名，到底是需要读取密码呢，还是密码已经被读取呢，不知道，所以这个变量可以使用<code>user_is_authenticated</code>代替。通常，给Boolean型变量添加<code>is</code>、<code>has</code>、<code>can</code>、<code>should</code>可以让含义更清晰，比如：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">             SpaceLeft()  --&gt;  hasSpaceLeft()
bool disable_ssl = false  --&gt;  bool use_ssl = true
</code></pre></div>
<h4>符合预期</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">public class StatisticsCollector {
    public void addSample(double x) { ... }
    public double getMean() {
        // Iterate through all samples and return total / num_samples
    }
    ...
}
</code></pre></div>
<p>在这个例子中，<code>getMean</code>方法遍历了所有的样本，返回总额，所以并不是普通意义上轻量的<code>get</code>方法，所以应该取名<code>computeMean</code>比较合适。</p>

<h2>漂亮的格式</h2>

<p>写出来漂亮的格式，充满美感，读起来自然也会舒服很多，对比下面两个例子：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class StatsKeeper {
   public:
   // A class for keeping track of a series of doubles
      void Add(double d);  // and methods for quick statistics about them
     private:   int count;        /* how many so    far
   */ public:
           double Average();
   private:   double minimum;
   list&lt;double&gt;
     past_items
         ;double maximum;
};
</code></pre></div>
<p>什么是充满美感的呢：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// A class for keeping track of a series of doubles
// and methods for quick statistics about them.
class StatsKeeper {
  public:
    void Add(double d);
    double Average();
  private:
    list&lt;double&gt; past_items;
    int count;  // how many so far
    double minimum;
    double maximum;
};
</code></pre></div>
<h3>考虑断行的连续性和简洁</h3>

<p>这段代码需要断行，来满足不超过一行80个字符的要求，参数也需要注释说明：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">public class PerformanceTester {
    public static final TcpConnectionSimulator wifi = new TcpConnectionSimulator(
        500, /* Kbps */
        80, /* millisecs latency */
        200, /* jitter */
        1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber = new TcpConnectionSimulator(
        45000, /* Kbps */
        10, /* millisecs latency */
        0, /* jitter */
        0 /* packet loss % */);

    public static final TcpConnectionSimulator cell = new TcpConnectionSimulator(
        100, /* Kbps */
        400, /* millisecs latency */
        250, /* jitter */
        5 /* packet loss % */);
}
</code></pre></div>
<p>考虑到代码的连贯性，先优化成这样：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">public class PerformanceTester {
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(
            500, /* Kbps */
            80, /* millisecs latency */ 200, /* jitter */
            1 /* packet loss % */);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(
            45000, /* Kbps */
            10,    /* millisecs latency */
            0,     /* jitter */
            0      /* packet loss % */);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(
            100,   /* Kbps */
            400,   /* millisecs latency */
            250,   /* jitter */
            5      /* packet loss % */);
}
</code></pre></div>
<p>连贯性好一点，但还是太罗嗦，额外占用很多空间：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">public class PerformanceTester {
    // TcpConnectionSimulator(throughput, latency, jitter, packet_loss)
    //                            [Kbps]   [ms]    [ms]    [percent]
    public static final TcpConnectionSimulator wifi =
        new TcpConnectionSimulator(500,    80,     200,     1);

    public static final TcpConnectionSimulator t3_fiber =
        new TcpConnectionSimulator(45000,  10,     0,       0);

    public static final TcpConnectionSimulator cell =
        new TcpConnectionSimulator(100,    400,    250,     5);
}
</code></pre></div>
<h3>用函数封装</h3>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Turn a partial_name like &quot;Doug Adams&quot; into &quot;Mr. Douglas Adams&quot;.
// If not possible, &#39;error&#39; is filled with an explanation.
string ExpandFullName(DatabaseConnection dc, string partial_name, string* error);

DatabaseConnection database_connection;
string error;
assert(ExpandFullName(database_connection, &quot;Doug Adams&quot;, &amp;error)
        == &quot;Mr. Douglas Adams&quot;);
assert(error == &quot;&quot;);
assert(ExpandFullName(database_connection, &quot; Jake Brown &quot;, &amp;error)
        == &quot;Mr. Jacob Brown III&quot;);
assert(error == &quot;&quot;);
assert(ExpandFullName(database_connection, &quot;No Such Guy&quot;, &amp;error) == &quot;&quot;);
assert(error == &quot;no match found&quot;);
assert(ExpandFullName(database_connection, &quot;John&quot;, &amp;error) == &quot;&quot;);
assert(error == &quot;more than one result&quot;);
</code></pre></div>
<p>上面这段代码看起来很脏乱，很多重复性的东西，可以用函数封装：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">CheckFullName(&quot;Doug Adams&quot;, &quot;Mr. Douglas Adams&quot;, &quot;&quot;);
CheckFullName(&quot; Jake Brown &quot;, &quot;Mr. Jake Brown III&quot;, &quot;&quot;);
CheckFullName(&quot;No Such Guy&quot;, &quot;&quot;, &quot;no match found&quot;);
CheckFullName(&quot;John&quot;, &quot;&quot;, &quot;more than one result&quot;);

void CheckFullName(string partial_name,
                   string expected_full_name,
                   string expected_error) {
    // database_connection is now a class member
    string error;
    string full_name = ExpandFullName(database_connection, partial_name, &amp;error);
    assert(error == expected_error);
    assert(full_name == expected_full_name);
}
</code></pre></div>
<h3>列对齐</h3>

<p>列对齐可以让代码段看起来更舒适：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">CheckFullName(&quot;Doug Adams&quot;   , &quot;Mr. Douglas Adams&quot; , &quot;&quot;);
CheckFullName(&quot; Jake  Brown &quot;, &quot;Mr. Jake Brown III&quot;, &quot;&quot;);
CheckFullName(&quot;No Such Guy&quot;  , &quot;&quot;                  , &quot;no match found&quot;);
CheckFullName(&quot;John&quot;         , &quot;&quot;                  , &quot;more than one result&quot;);

commands[] = {
    ...
    { &quot;timeout&quot;      , NULL              , cmd_spec_timeout},
    { &quot;timestamping&quot; , &amp;opt.timestamping , cmd_boolean},
    { &quot;tries&quot;        , &amp;opt.ntry         , cmd_number_inf},
    { &quot;useproxy&quot;     , &amp;opt.use_proxy    , cmd_boolean},
    { &quot;useragent&quot;    , NULL              , cmd_spec_useragent},
    ...
};
</code></pre></div>
<h3>代码用块区分</h3>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class FrontendServer {
    public:
        FrontendServer();
        void ViewProfile(HttpRequest* request);
        void OpenDatabase(string location, string user);
        void SaveProfile(HttpRequest* request);
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void FindFriends(HttpRequest* request);
        void ReplyNotFound(HttpRequest* request, string error);
        void CloseDatabase(string location);
        ~FrontendServer();
};
</code></pre></div>
<p>上面这一段虽然能看，不过还有优化空间：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class FrontendServer {
    public:
        FrontendServer();
        ~FrontendServer();
        // Handlers
        void ViewProfile(HttpRequest* request);
        void SaveProfile(HttpRequest* request);
        void FindFriends(HttpRequest* request);

        // Request/Reply Utilities
        string ExtractQueryParam(HttpRequest* request, string param);
        void ReplyOK(HttpRequest* request, string html);
        void ReplyNotFound(HttpRequest* request, string error);

        // Database Helpers
        void OpenDatabase(string location, string user);
        void CloseDatabase(string location);
};
</code></pre></div>
<p>再来看一段代码：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># Import the user&#39;s email contacts, and match them to users in our system.
# Then display a list of those users that he/she isn&#39;t already friends with.
def suggest_new_friends(user, email_password):
    friends = user.friends()
    friend_emails = set(f.email for f in friends)
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)
    display[&#39;user&#39;] = user
    display[&#39;friends&#39;] = friends
    display[&#39;suggested_friends&#39;] = suggested_friends
    return render(&quot;suggested_friends.html&quot;, display)
</code></pre></div>
<p>全都混在一起，视觉压力相当大，按功能化块：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def suggest_new_friends(user, email_password):
    # Get the user&#39;s friends&#39; email addresses.
    friends = user.friends()
    friend_emails = set(f.email for f in friends)

    # Import all email addresses from this user&#39;s email account.
    contacts = import_contacts(user.email, email_password)
    contact_emails = set(c.email for c in contacts)

    # Find matching users that they aren&#39;t already friends with.
    non_friend_emails = contact_emails - friend_emails
    suggested_friends = User.objects.select(email__in=non_friend_emails)

    # Display these lists on the page. display[&#39;user&#39;] = user
    display[&#39;friends&#39;] = friends
    display[&#39;suggested_friends&#39;] = suggested_friends

    return render(&quot;suggested_friends.html&quot;, display)
</code></pre></div>
<p>让代码看起来更舒服，需要在写的过程中多注意，培养一些好的习惯，尤其当团队合作的时候，代码风格比如大括号的位置并没有对错，但是不遵循团队规范那就是错的。</p>

<h2>如何写注释</h2>

<p>当你写代码的时候，你会思考很多，但是最终呈现给读者的就只剩代码本身了，额外的信息丢失了，所以注释的目的就是让读者了解更多的信息。</p>

<h3>应该注释什么</h3>

<h4>不应该注释什么</h4>

<p>这样的注释毫无价值：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// The class definition for Account
class Account {
    public:
        // Constructor
        Account();
        // Set the profit member to a new value
        void SetProfit(double profit);
        // Return the profit from this Account
        double GetProfit();
};
</code></pre></div>
<h4>不要像下面这样为了注释而注释：</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Find a Node with the given &#39;name&#39; or return NULL.
// If depth &lt;= 0, only &#39;subtree&#39; is inspected.
// If depth == N, only &#39;subtree&#39; and N levels below are inspected.
Node* FindNodeInSubtree(Node* subtree, string name, int depth);
</code></pre></div>
<h4>不要给烂取名注释</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Enforce limits on the Reply as stated in the Request,
// such as the number of items returned, or total byte size, etc. 
void CleanReply(Request request, Reply reply);
</code></pre></div>
<p>注释的大部分都在解释clean是什么意思，那不如换个正确的名字：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Make sure &#39;reply&#39; meets the count/byte/etc. limits from the &#39;request&#39; 
void EnforceLimitsFromRequest(Request request, Reply reply);
</code></pre></div>
<h4>记录你的想法</h4>

<p>我们讨论了不该注释什么，那么应该注释什么呢？注释应该记录你思考代码怎么写的结果，比如像下面这些：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Surprisingly, a binary tree was 40% faster than a hash table for this data.
// The cost of computing a hash was more than the left/right comparisons.

// This heuristic might miss a few words. That&#39;s OK; solving this 100% is hard.

// This class is getting messy. Maybe we should create a &#39;ResourceNode&#39; subclass to
// help organize things.
</code></pre></div>
<p>也可以用来记录流程和常量：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// TODO: use a faster algorithm
// TODO(dustin): handle other image formats besides JPEG

NUM_THREADS = 8 # as long as it&#39;s &gt;= 2 * num_processors, that&#39;s good enough.

// Impose a reasonable limit - no human can read that much anyway.
const int MAX_RSS_SUBSCRIPTIONS = 1000;
</code></pre></div>
<p>可用的词有：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">TODO  : Stuff I haven&#39;t gotten around to yet
FIXME : Known-broken code here
HACK  : Adimittedly inelegant solution to a problem
XXX   : Danger! Major problem here
</code></pre></div>
<h4>站在读者的角度去思考</h4>

<p>当别人读你的代码时，让他们产生疑问的部分，就是你应该注释的地方。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">struct Recorder {
    vector&lt;float&gt; data;
    ...
    void Clear() {
        vector&lt;float&gt;().swap(data); // Huh? Why not just data.clear()? 
    }
};
</code></pre></div>
<p>很多C++的程序员啊看到这里，可能会想为什么不用<code>data.clear()</code>来代替<code>vector.swap</code>，所以那个地方应该加上注释：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Force vector to relinquish its memory (look up &quot;STL swap trick&quot;)
vector&lt;float&gt;().swap(data);
</code></pre></div>
<h4>说明可能陷阱</h4>

<p>你在写代码的过程中，可能用到一些hack，或者有其他需要读代码的人知道的陷阱，这时候就应该注释：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">void SendEmail(string to, string subject, string body);
</code></pre></div>
<p>而实际上这个发送邮件的函数是调用别的服务，有超时设置，所以需要注释：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Calls an external service to deliver email.  (Times out after 1 minute.)
void SendEmail(string to, string subject, string body);
</code></pre></div>
<h4>全景的注释</h4>

<p>有时候为了更清楚说明，需要给整个文件加注释，让读者有个总体的概念：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// This file contains helper functions that provide a more convenient interface to our
// file system. It handles file permissions and other nitty-gritty details.
</code></pre></div>
<h4>总结性的注释</h4>

<p>即使是在函数内部，也可以有类似文件注释那样的说明注释：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># Find all the items that customers purchased for themselves.
for customer_id in all_customers:
    for sale in all_sales[customer_id].sales:
        if sale.recipient == customer_id:
            ...
</code></pre></div>
<p>或者按照函数的步进，写一些注释：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def GenerateUserReport():
    # Acquire a lock for this user
    ...
    # Read user&#39;s info from the database
    ...
    # Write info to a file
    ...
    # Release the lock for this user
</code></pre></div>
<p>很多人不愿意写注释，确实，要写好注释也不是一件简单的事情，也可以在文件专门的地方，留个写注释的区域，可以写下你任何想说的东西。</p>

<h3>注释应简明准确</h3>

<p>前一个小节讨论了注释应该写什么，这一节来讨论应该怎么写，因为注释很重要，所以要写的精确，注释也占据屏幕空间，所以要简洁。</p>

<h4>精简注释</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// The int is the CategoryType.
// The first float in the inner pair is the &#39;score&#39;,
// the second is the &#39;weight&#39;.
typedef hash_map&lt;int, pair&lt;float, float&gt; &gt; ScoreMap;
</code></pre></div>
<p>这样写太罗嗦了，尽量精简压缩成这样：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// CategoryType -&gt; (score, weight)
typedef hash_map&lt;int, pair&lt;float, float&gt; &gt; ScoreMap;
</code></pre></div>
<h4>避免有歧义的代词</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Insert the data into the cache, but check if it&#39;s too big first.
</code></pre></div>
<p>这里的<code>it&#39;s</code>有歧义，不知道所指的是<code>data</code>还是<code>cache</code>，改成如下：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Insert the data into the cache, but check if the data is too big first.
</code></pre></div>
<p>还有更好的解决办法，这里的<code>it</code>就有明确所指：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// If the data is small enough, insert it into the cache.
</code></pre></div>
<h4>语句要精简准确</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># Depending on whether we&#39;ve already crawled this URL before, give it a different priority.
</code></pre></div>
<p>这句话理解起来太费劲，改成如下就好理解很多：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># Give higher priority to URLs we&#39;ve never crawled before.
</code></pre></div>
<h4>精确描述函数的目的</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Return the number of lines in this file.
int CountLines(string filename) { ... }
</code></pre></div>
<p>这样的一个函数，用起来可能会一头雾水，因为他可以有很多歧义：</p>

<ul>
<li> &quot;&quot; 一个空文件，是0行还是1行？</li>
<li> &quot;hello&quot; 只有一行，那么返回值是0还是1？</li>
<li> &quot;hello\n&quot; 这种情况返回1还是2？</li>
<li> &quot;hello\n world&quot; 返回1还是2？</li>
<li> &quot;hello\n\r cruel\n world\r&quot; 返回2、3、4哪一个呢？</li>
</ul>

<p>所以注释应该这样写：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Count how many newline bytes (&#39;\n&#39;) are in the file.
int CountLines(string filename) { ... }
</code></pre></div>
<h4>用实例说明边界情况</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Rearrange &#39;v&#39; so that elements &lt; pivot come before those &gt;= pivot;
// Then return the largest &#39;i&#39; for which v[i] &lt; pivot (or -1 if none are &lt; pivot)
int Partition(vector&lt;int&gt;* v, int pivot);
</code></pre></div>
<p>这个描述很精确，但是如果再加入一个例子，就更好了：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// ...
// Example: Partition([8 5 9 8 2], 8) might result in [5 2 | 8 9 8] and return 1
int Partition(vector&lt;int&gt;* v, int pivot);
</code></pre></div>
<h4>说明你的代码的真正目的</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">void DisplayProducts(list&lt;Product&gt; products) {
    products.sort(CompareProductByPrice);
    // Iterate through the list in reverse order
    for (list&lt;Product&gt;::reverse_iterator it = products.rbegin(); it != products.rend();
            ++it)
        DisplayPrice(it-&gt;price);
    ... 
}
</code></pre></div>
<p>这里的注释说明了倒序排列，单还不够准确，应该改成这样：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Display each price, from highest to lowest
for (list&lt;Product&gt;::reverse_iterator it = products.rbegin(); ... )
</code></pre></div>
<h4>函数调用时的注释</h4>

<p>看见这样的一个函数调用，肯定会一头雾水：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">Connect(10, false);
</code></pre></div>
<p>如果加上这样的注释，读起来就清楚多了：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def Connect(timeout, use_encryption):  ...

# Call the function using named parameters
Connect(timeout = 10, use_encryption = False)
</code></pre></div>
<h4>使用信息含量丰富的词</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// This class contains a number of members that store the same information as in the
// database, but are stored here for speed. When this class is read from later, those
// members are checked first to see if they exist, and if so are returned; otherwise the
// database is read from and that data stored in those fields for next time.
</code></pre></div>
<p>上面这一大段注释，解释的很清楚，如果换一个词来代替，也不会有什么疑惑：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// This class acts as a caching layer to the database.
</code></pre></div>
<h2>简化循环和逻辑</h2>

<h3>流程控制要简单</h3>

<p>让条件语句、循环以及其他控制流程的代码尽可能自然，让读者在阅读过程中不需要停顿思考或者在回头查找，是这一节的目的。</p>

<h4>条件语句中参数的位置</h4>

<p>对比下面两种条件的写法：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (length &gt;= 10)
while (bytes_received &lt; bytes_expected)

if (10 &lt;= length)
while (bytes_expected &gt; bytes_received)
</code></pre></div>
<p>到底是应该按照大于小于的顺序来呢，还是有其他的准则？是的，应该按照参数的意义来</p>

<ul>
<li>运算符左边：通常是需要被检查的变量，也就是会经常变化的</li>
<li>运算符右边：通常是被比对的样本，一定程度上的常量</li>
</ul>

<p>这就解释了为什么<code>bytes_received &lt; bytes_expected</code>比反过来更好理解。</p>

<h4>if/else的顺序</h4>

<p>通常，<code>if/else</code>的顺序你可以自由选择，下面这两种都可以：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (a == b) {
    // Case One ...
} else {
    // Case Two ...
}

if (a != b) {
    // Case Two ...
} else {
    // Case One ...
}
</code></pre></div>
<p>或许对此你也没有仔细斟酌过，但在有些时候，一种顺序确实好过另一种：</p>

<ul>
<li>正向的逻辑在前，比如<code>if(debug)</code>就比<code>if(!debug)</code>好</li>
<li>简单逻辑的在前，这样<code>if</code>和<code>else</code>就可以在一个屏幕显示</li>
<li>有趣、清晰的逻辑在前</li>
</ul>

<p>举个例子来看：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (!url.HasQueryParameter(&quot;expand_all&quot;)) {
    response.Render(items);
    ...
} else {
    for (int i = 0; i &lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
}
</code></pre></div>
<p>看到<code>if</code>你首先想到的是<code>expand_all</code>，就好像告诉你“不要想大象”，你会忍不住去想它，所以产生了一点点迷惑，最好写成：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (url.HasQueryParameter(&quot;expand_all&quot;)) {
    for (int i = 0; i &lt; items.size(); i++) {
        items[i].Expand();
    }
    ... 
} else {
    response.Render(items);
    ... 
}
</code></pre></div>
<h4>三目运算符(?:)</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">time_str += (hour &gt;= 12) ? &quot;pm&quot; : &quot;am&quot;;

Avoiding the ternary operator, you might write:
    if (hour &gt;= 12) {
        time_str += &quot;pm&quot;;
    } else {
        time_str += &quot;am&quot;;
}
</code></pre></div>
<p>使用三目运算符可以减少代码行数，上例就是一个很好的例证，但是我们的真正目的是减少读代码的时间，所以下面的情况并不适合用三目运算符：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">return exponent &gt;= 0 ? mantissa * (1 &lt;&lt; exponent) : mantissa / (1 &lt;&lt; -exponent);

if (exponent &gt;= 0) {
    return mantissa * (1 &lt;&lt; exponent);
} else {
    return mantissa / (1 &lt;&lt; -exponent);
}
</code></pre></div>
<p>所以只在简单表达式的地方用。</p>

<h4>避免使用do/while表达式</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">do {
    continue;
} while (false);
</code></pre></div>
<p>这段代码会执行几遍呢，需要时间思考一下，<code>do/while</code>完全可以用别的方法代替，所以应避免使用。</p>

<h4>尽早return</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">public boolean Contains(String str, String substr) {
    if (str == null || substr == null) return false;
    if (substr.equals(&quot;&quot;)) return true;
    ...
}
</code></pre></div>
<p>函数里面尽早的return，可以让逻辑更加清晰。</p>

<h4>减少嵌套</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (user_result == SUCCESS) {
    if (permission_result != SUCCESS) {
        reply.WriteErrors(&quot;error reading permissions&quot;);
        reply.Done();
        return;
    }
    reply.WriteErrors(&quot;&quot;);
} else {
    reply.WriteErrors(user_result);
}
reply.Done();
</code></pre></div>
<p>这样一段代码，有一层的嵌套，但是看起来也会稍有迷惑，想想自己的代码，有没有类似的情况呢？可以换个思路去考虑这段代码，并且用尽早return的原则修改，看起来就舒服很多：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (user_result != SUCCESS) {
    reply.WriteErrors(user_result);
    reply.Done();
    return;
}
if (permission_result != SUCCESS) {
    reply.WriteErrors(permission_result);
    reply.Done();
    return;
}
reply.WriteErrors(&quot;&quot;);
reply.Done();
</code></pre></div>
<p>同样的，对于有嵌套的循环，可以采用同样的办法：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">for (int i = 0; i &lt; results.size(); i++) {
    if (results[i] != NULL) {
        non_null_count++;
        if (results[i]-&gt;name != &quot;&quot;) {
            cout &lt;&lt; &quot;Considering candidate...&quot; &lt;&lt; endl;
            ...
        }
    }
}
</code></pre></div>
<p>换一种写法，尽早return，在循环中就用continue：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">for (int i = 0; i &lt; results.size(); i++) {
    if (results[i] == NULL) continue;
    non_null_count++;

    if (results[i]-&gt;name == &quot;&quot;) continue;
    cout &lt;&lt; &quot;Considering candidate...&quot; &lt;&lt; endl;
    ... 
}
</code></pre></div>
<h3>拆分复杂表达式</h3>

<p>很显然的，越复杂的表达式，读起来越费劲，所以应该把那些复杂而庞大的表达式，拆分成一个个易于理解的小式子。</p>

<h4>用变量</h4>

<p>将复杂表达式拆分最简单的办法，就是增加一个变量：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if line.split(&#39;:&#39;)[0].strip() == &quot;root&quot;:

//用变量替换
username = line.split(&#39;:&#39;)[0].strip() 
if username == &quot;root&quot;:
    ...
</code></pre></div>
<p>或者这个例子：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (request.user.id == document.owner_id) {
    // user can edit this document...
}
...
if (request.user.id != document.owner_id) {
// document is read-only...
}

//用变量替换
final boolean user_owns_document = (request.user.id == document.owner_id);
if (user_owns_document) {
    // user can edit this document...
}
...
if (!user_owns_document) {
    // document is read-only...
}
</code></pre></div>
<h4>逻辑替换</h4>

<ul>
<li>1) not (a or b or c)   &lt;--&gt; (not a) and (not b) and (not c) </li>
<li>2) not (a and b and c) &lt;--&gt; (not a) or (not b) or (not c)</li>
</ul>

<p>所以，就可以这样写：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (!(file_exists &amp;&amp; !is_protected)) Error(&quot;Sorry, could not read file.&quot;);

//替换
if (!file_exists || is_protected) Error(&quot;Sorry, could not read file.&quot;);
</code></pre></div>
<h4>不要滥用逻辑表达式</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">assert((!(bucket = FindBucket(key))) || !bucket-&gt;IsOccupied());
</code></pre></div>
<p>这样的代码完全可以用下面这个替换，虽然有两行，但是更易懂：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">bucket = FindBucket(key);
if (bucket != NULL) assert(!bucket-&gt;IsOccupied());
</code></pre></div>
<p>像下面这样的表达式，最好也不要写，因为在有些语言中，x会被赋予第一个为<code>true</code>的变量的值：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">x = a || b || c
</code></pre></div>
<h4>拆解大表达式</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var update_highlight = function (message_num) {
    if ($(&quot;#vote_value&quot; + message_num).html() === &quot;Up&quot;) {
        $(&quot;#thumbs_up&quot; + message_num).addClass(&quot;highlighted&quot;);
        $(&quot;#thumbs_down&quot; + message_num).removeClass(&quot;highlighted&quot;);
    } else if ($(&quot;#vote_value&quot; + message_num).html() === &quot;Down&quot;) {
        $(&quot;#thumbs_up&quot; + message_num).removeClass(&quot;highlighted&quot;);
        $(&quot;#thumbs_down&quot; + message_num).addClass(&quot;highlighted&quot;);
    } else {
        $(&quot;#thumbs_up&quot; + message_num).removeClass(&quot;highighted&quot;);
        $(&quot;#thumbs_down&quot; + message_num).removeClass(&quot;highlighted&quot;);
    }
};
</code></pre></div>
<p>这里面有很多重复的语句，我们可以用变量还替换简化：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var update_highlight = function (message_num) {
    var thumbs_up = $(&quot;#thumbs_up&quot; + message_num);
    var thumbs_down = $(&quot;#thumbs_down&quot; + message_num);
    var vote_value = $(&quot;#vote_value&quot; + message_num).html();
    var hi = &quot;highlighted&quot;;

    if (vote_value === &quot;Up&quot;) {
        thumbs_up.addClass(hi);
        thumbs_down.removeClass(hi);
    } else if (vote_value === &quot;Down&quot;) {
        thumbs_up.removeClass(hi);
        thumbs_down.addClass(hi);
    } else {
        thumbs_up.removeClass(hi);
        thumbs_down.removeClass(hi);
    }
}
</code></pre></div>
<h3>变量与可读性</h3>

<h4>消除变量</h4>

<p>前一节，讲到利用变量来拆解大表达式，这一节来讨论如何消除多余的变量。</p>

<h4>没用的临时变量</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">now = datetime.datetime.now()
root_message.last_view_time = now
</code></pre></div>
<p>这里的<code>now</code>可以去掉，因为：</p>

<ul>
<li>并非用来拆分复杂的表达式</li>
<li>也没有增加可读性，因为`datetime.datetime.now()`本就清晰</li>
<li>只用了一次</li>
</ul>

<p>所以完全可以写作：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">root_message.last_view_time = datetime.datetime.now()
</code></pre></div>
<h4>消除条件控制变量</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">boolean done = false;
while (/* condition */ &amp;&amp; !done) {
    ...
    if (...) {
        done = true;
        continue; 
    }
}
</code></pre></div>
<p>这里的<code>done</code>可以用别的方式更好的完成：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">while (/* condition */) {
    ...
    if (...) {
        break;
    } 
}
</code></pre></div>
<p>这个例子非常容易修改，如果是比较复杂的嵌套，<code>break</code>可能并不够用，这时候就可以把代码封装到函数中。</p>

<h4>减少变量的作用域</h4>

<p>我们都听过要避免使用全局变量这样的忠告，是的，当变量的作用域越大，就越难追踪，所以要保持变量小的作用域。</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class LargeClass {
    string str_;
    void Method1() {
        str_ = ...;
        Method2();
    }
    void Method2() {
        // Uses str_
    }
    // Lots of other methods that don&#39;t use str_ 
    ... ;
}
</code></pre></div>
<p>这里的<code>str_</code>的作用域有些大，完全可以换一种方式：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">class LargeClass {
    void Method1() {
        string str = ...;
        Method2(str); 
    }
    void Method2(string str) {
        // Uses str
    }
    // Now other methods can&#39;t see str.
};
</code></pre></div>
<p>将<code>str</code>通过变量函数参数传递，减小了作用域，也更易读。同样的道理也可以用在定义类的时候，将大类拆分成一个个小类。</p>

<h4>不要使用嵌套的作用域</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text"># No use of example_value up to this point.
if request:
    for value in request.values:
    if value &gt; 0:
        example_value = value 
        break

for logger in debug.loggers:
    logger.log(&quot;Example:&quot;, example_value)
</code></pre></div>
<p>这个例子在运行时候会报<code>example_value is undefined</code>的错，修改起来不算难：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">example_value = None
if request:
    for value in request.values:
        if value &gt; 0: example_value = value 
        break

if example_value:
    for logger in debug.loggers:
    logger.log(&quot;Example:&quot;, example_value)
</code></pre></div>
<p>但是参考前面的<strong>消除中间变量</strong>准则，还有更好的办法：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def LogExample(value):
    for logger in debug.loggers:
        logger.log(&quot;Example:&quot;, value)

    if request:
        for value in request.values:
            if value &gt; 0:
                LogExample(value)  # deal with &#39;value&#39; immediately
                break
</code></pre></div>
<h4>用到了再声明</h4>

<p>在C语言中，要求将所有的变量事先声明，这样当用到变量较多时候，读者处理这些信息就会有难度，所以一开始没用到的变量，就暂缓声明：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def ViewFilteredReplies(original_id):
    filtered_replies = []
    root_message = Messages.objects.get(original_id) 
    all_replies = Messages.objects.select(root_id=original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    for reply in all_replies:
        if reply.spam_votes &lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
</code></pre></div>
<p>读者一次处理变量太多，可以暂缓声明：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def ViewFilteredReplies(original_id):
    root_message = Messages.objects.get(original_id)
    root_message.view_count += 1
    root_message.last_view_time = datetime.datetime.now()
    root_message.save()

    all_replies = Messages.objects.select(root_id=original_id) 
    filtered_replies = []
    for reply in all_replies:
        if reply.spam_votes &lt;= MAX_SPAM_VOTES:
            filtered_replies.append(reply)

    return filtered_replies
</code></pre></div>
<h4>变量最好只写一次</h4>

<p>前面讨论了过多的变量会让读者迷惑，同一个变量，不停的被赋值也会让读者头晕，如果变量变化的次数少一些，代码可读性就更强。</p>

<h4>一个例子</h4>

<p>假设有一个页面，如下，需要给第一个空的<code>input</code>赋值：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&lt;input type=&quot;text&quot; id=&quot;input1&quot; value=&quot;Dustin&quot;&gt;
&lt;input type=&quot;text&quot; id=&quot;input2&quot; value=&quot;Trevor&quot;&gt;
&lt;input type=&quot;text&quot; id=&quot;input3&quot; value=&quot;&quot;&gt;
&lt;input type=&quot;text&quot; id=&quot;input4&quot; value=&quot;Melissa&quot;&gt;
...
var setFirstEmptyInput = function (new_value) {
    var found = false;
    var i = 1;
    var elem = document.getElementById(&#39;input&#39; + i);
    while (elem !== null) {
        if (elem.value === &#39;&#39;) {
            found = true;
            break; 
        }
        i++;
        elem = document.getElementById(&#39;input&#39; + i);
    }
    if (found) elem.value = new_value;
    return elem;
};
</code></pre></div>
<p>这段代码能工作，有三个变量，我们逐一去看如何优化，<code>found</code>作为中间变量，完全可以消除：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var setFirstEmptyInput = function (new_value) {
    var i = 1;
    var elem = document.getElementById(&#39;input&#39; + i);
    while (elem !== null) {
        if (elem.value === &#39;&#39;) {
            elem.value = new_value;
            return elem;
        }
        i++;
        elem = document.getElementById(&#39;input&#39; + i);
    }
    return null;
};
</code></pre></div>
<p>再来看<code>elem</code>变量，只用来做循环，调用了很多次，所以很难跟踪他的值，<code>i</code>也可以用<code>for</code>来修改：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var setFirstEmptyInput = function (new_value) {
    for (var i = 1; true; i++) {
        var elem = document.getElementById(&#39;input&#39; + i);
        if (elem === null)
            return null;  // Search Failed. No empty input found.
        if (elem.value === &#39;&#39;) {
            elem.value = new_value;
            return elem;
        }
    }
};
</code></pre></div>
<h2>重新组织你的代码</h2>

<h3>分离不相关的子问题</h3>

<p>工程师就是将大问题分解为一个个小问题，然后逐个解决，这样也易于保证程序的健壮性、可读性。如何分解子问题，下面给出一些准则：</p>

<ul>
<li>看看这个方法或代码，问问你自己“这段代码的最终目标是什么？”</li>
<li>对于每一行代码，要问“它与目标直接相关，或者是不相关的子问题？”</li>
<li>如果有足够多行的代码是处理与目标不直接相关的问题，那么抽离成子函数</li>
</ul>

<p>来看一个例子：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ajax_post({
    url: &#39;http://example.com/submit&#39;,
    data: data,
    on_success: function (response_data) {
        var str = &quot;{\n&quot;;
        for (var key in response_data) {
            str += &quot;  &quot; + key + &quot; = &quot; + response_data[key] + &quot;\n&quot;;
        }
        alert(str + &quot;}&quot;);
        // Continue handling &#39;response_data&#39; ...
    }
});
</code></pre></div>
<p>这段代码的目标是发送一个<code>ajax</code>请求，所以其中字符串处理的部分就可以抽离出来：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var format_pretty = function (obj) {
    var str = &quot;{\n&quot;;
    for (var key in obj) {
        str += &quot;  &quot; + key + &quot; = &quot; + obj[key] + &quot;\n&quot;;
    }
    return str + &quot;}&quot;;
};
</code></pre></div>
<h4>意外收获</h4>

<p>有很多理由将<code>format_pretty</code>抽离出来，这些独立的函数可以很容易的添加feature，增强可靠性，处理边界情况，等等。所以这里，可以将<code>format_pretty</code>增强，就会得到一个更强大的函数：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var format_pretty = function (obj, indent) {
    // Handle null, undefined, strings, and non-objects.
    if (obj === null) return &quot;null&quot;;
    if (obj === undefined) return &quot;undefined&quot;;
    if (typeof obj === &quot;string&quot;) return &#39;&quot;&#39; + obj + &#39;&quot;&#39;;
    if (typeof obj !== &quot;object&quot;) return String(obj);
    if (indent === undefined) indent = &quot;&quot;;

    // Handle (non-null) objects.

    var str = &quot;{\n&quot;;
    for (var key in obj) {
        str += indent + &quot;  &quot; + key + &quot; = &quot;;
        str += format_pretty(obj[key], indent + &quot; &quot;) + &quot;\n&quot;; }
    return str + indent + &quot;}&quot;;
};
</code></pre></div>
<p>这个函数输出：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">{
    key1 = 1
    key2 = true
    key3 = undefined
    key4 = null
    key5 = {
        key5a = {
            key5a1 = &quot;hello world&quot;
        }
    }
}
</code></pre></div>
<p>多做这样的事情，就是积累代码的过程，这样的代码可以复用，也可以形成自己的代码库，或者分享给别人。</p>

<h4>业务相关的函数</h4>

<p>那些与目标不相关函数，抽离出来可以复用，与业务相关的也可以抽出来，保持代码的易读性，例如：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">business = Business()
business.name = request.POST[&quot;name&quot;]

url_path_name = business.name.lower()
url_path_name = re.sub(r&quot;[&#39;\.]&quot;, &quot;&quot;, url_path_name) 
url_path_name = re.sub(r&quot;[^a-z0-9]+&quot;, &quot;-&quot;, url_path_name) 
url_path_name = url_path_name.strip(&quot;-&quot;)
business.url = &quot;/biz/&quot; + url_path_name

business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
</code></pre></div>
<p>抽离出来，就好看很多：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">CHARS_TO_REMOVE = re.compile(r&quot;[&#39;\.&#39;]+&quot;)
CHARS_TO_DASH = re.compile(r&quot;[^a-z0-9]+&quot;)

def make_url_friendly(text):
    text = text.lower()
    text = CHARS_TO_REMOVE.sub(&#39;&#39;, text) 
    text = CHARS_TO_DASH.sub(&#39;-&#39;, text) 
    return text.strip(&quot;-&quot;)

business = Business()
business.name = request.POST[&quot;name&quot;]
business.url = &quot;/biz/&quot; + make_url_friendly(business.name) 
business.date_created = datetime.datetime.utcnow() 
business.save_to_database()
</code></pre></div>
<h4>简化现有接口</h4>

<p>我们来看一个读写cookie的函数：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var max_results;
var cookies = document.cookie.split(&#39;;&#39;);
for (var i = 0; i &lt; cookies.length; i++) {
    var c = cookies[i];
    c = c.replace(/^[ ]+/, &#39;&#39;);  // remove leading spaces
    if (c.indexOf(&quot;max_results=&quot;) === 0)
        max_results = Number(c.substring(12, c.length));
}
</code></pre></div>
<p>这段代码实在太丑了，理想的接口应该是这样的：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">set_cookie(name, value, days_to_expire);
delete_cookie(name);
</code></pre></div>
<p>对于并不理想的接口，你永远可以用自己的函数做封装，让接口更好用。</p>

<h4>按自己需要写接口</h4>
<div class="highlight"><pre><code class="text language-text" data-lang="text">ser_info = { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; }
user_str = json.dumps(user_info)
cipher = Cipher(&quot;aes_128_cbc&quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE)
encrypted_bytes = cipher.update(user_str)
encrypted_bytes += cipher.final() # flush out the current 128 bit block
url = &quot;http://example.com/?user_info=&quot; + base64.urlsafe_b64encode(encrypted_bytes)
...
</code></pre></div>
<p>虽然终极目的是拼接用户信息的字符，但是代码大部分做的事情是解析python的object，所以：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">def url_safe_encrypt(obj):
    obj_str = json.dumps(obj)
    cipher = Cipher(&quot;aes_128_cbc&quot;, key=PRIVATE_KEY, init_vector=INIT_VECTOR, op=ENCODE) encrypted_bytes = cipher.update(obj_str)
    encrypted_bytes += cipher.final() # flush out the current 128 bit block
    return base64.urlsafe_b64encode(encrypted_bytes)
</code></pre></div>
<p>这样在其他地方也可以调用：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">user_info = { &quot;username&quot;: &quot;...&quot;, &quot;password&quot;: &quot;...&quot; }
url = &quot;http://example.com/?user_info=&quot; + url_safe_encrypt(user_info)
</code></pre></div>
<p>分离子函数是好习惯，但是也要适度，过度的分离成多个小函数，也会让查找变得困难。</p>

<h3>单任务</h3>

<p>代码应该是一次只完成一个任务</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var place = location_info[&quot;LocalityName&quot;];  // e.g. &quot;Santa Monica&quot;
if (!place) {
    place = location_info[&quot;SubAdministrativeAreaName&quot;];  // e.g. &quot;Los Angeles&quot;
}
if (!place) {
    place = location_info[&quot;AdministrativeAreaName&quot;];  // e.g. &quot;California&quot;
}
if (!place) {
    place = &quot;Middle-of-Nowhere&quot;;
}
if (location_info[&quot;CountryName&quot;]) {
    place += &quot;, &quot; + location_info[&quot;CountryName&quot;];  // e.g. &quot;USA&quot;
} else {
    place += &quot;, Planet Earth&quot;;
}

return place;
</code></pre></div>
<p>这是一个用来拼地名的函数，有很多的条件判断，读起来非常吃力，有没有办法拆解任务呢？</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var town    = location_info[&quot;LocalityName&quot;];               // e.g. &quot;Santa Monica&quot;
var city    = location_info[&quot;SubAdministrativeAreaName&quot;];  // e.g. &quot;Los Angeles&quot;
var state   = location_info[&quot;AdministrativeAreaName&quot;];     // e.g. &quot;CA&quot;
var country = location_info[&quot;CountryName&quot;];                // e.g. &quot;USA&quot;
</code></pre></div>
<p>先拆解第一个任务，将各变量分别保存，这样在后面使用中不需要去记忆那些繁长的key值了，第二个任务，解决地址拼接的后半部分：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">// Start with the default, and keep overwriting with the most specific value. var second_half = &quot;Planet Earth&quot;;
if (country) {
    second_half = country; 
}
if (state &amp;&amp; country === &quot;USA&quot;) {
    second_half = state; 
}
</code></pre></div>
<p>再来解决前半部分：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var first_half = &quot;Middle-of-Nowhere&quot;;
if (state &amp;&amp; country !== &quot;USA&quot;) {
    first_half = state; 
}
if (city) {
    first_half = city;
}
if (town) {
    first_half = town; 
}
</code></pre></div>
<p>大功告成：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">return first_half + &quot;, &quot; + second_half;
</code></pre></div>
<p>如果注意到有<code>USA</code>这个变量的判断的话，也可以这样写：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">var first_half, second_half;
if (country === &quot;USA&quot;) {
    first_half = town || city || &quot;Middle-of-Nowhere&quot;;
    second_half = state || &quot;USA&quot;;
} else {
    first_half = town || city || state || &quot;Middle-of-Nowhere&quot;;
    second_half = country || &quot;Planet Earth&quot;;
}
return first_half + &quot;, &quot; + second_half;
</code></pre></div>
<h3>把想法转换成代码</h3>

<p>要把一个复杂的东西解释给别人，一些细节很容易就让人产生迷惑，所以想象把你的代码用平实的语言解释给别人听，别人是否能懂，有一些准则可以帮助你让代码更清晰：</p>

<ul>
<li>用最平实的语言描述代码的目的，就像给读者讲述一样</li>
<li>注意描述中关键的字词</li>
<li>让你的代码符合你的描述</li>
</ul>

<p>下面这段代码用来校验用户的权限：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">$is_admin = is_admin_request();
if ($document) {
    if (!$is_admin &amp;&amp; ($document[&#39;username&#39;] != $_SESSION[&#39;username&#39;])) {
        return not_authorized();
    }
} else {
    if (!$is_admin) {
        return not_authorized();
    } 
}
// continue rendering the page ...
</code></pre></div>
<p>这一段代码不长，里面的逻辑嵌套倒是复杂，参考前面章节所述，嵌套太多非常影响阅读理解，将这个逻辑用语言描述就是：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">有两种情况有权限：
1、你是管理员(admin)
2、你拥有这个文档
否则就没有权限
</code></pre></div>
<p>根据描述来写代码：</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">if (is_admin_request()) {
    // authorized
} elseif ($document &amp;&amp; ($document[&#39;username&#39;] == $_SESSION[&#39;username&#39;])) {
    // authorized
} else {
    return not_authorized();
}
// continue rendering the page ...
</code></pre></div>
<h3>写更少的代码</h3>

<p>最易懂的代码就是没有代码！</p>

<ul>
<li>去掉那些没意义的feature，也不要过度设计</li>
<li>重新考虑需求，解决最简单的问题，也能完成整体的目标</li>
<li>熟悉你常用的库，周期性研究他的API</li>
</ul>

<h2>最后</h2>

<p>还有一些与测试相关的章节，留给你自己去研读吧，再次推荐此书：</p>

<ul>
<li>英文版：<a href="http://book.douban.com/subject/5442971/" title="The Art Of Readable Code">《The Art of Readable Code》</a></li>
<li>中文版：<a href="http://book.douban.com/subject/10797189/" title="编写可读代码的艺术">编写可读代码的艺术</a></li>
</ul>

    </article>
    
    
    <div style="height: 64px"></div>
    
</div>

    
</body>
</html>
